/-
Copyright (c) 2018 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Johannes H√∂lzl
-/
import topology.uniform_space.uniform_convergence
import topology.uniform_space.uniform_embedding
import topology.uniform_space.complete_separated
import topology.uniform_space.compact
import topology.algebra.group.basic
import tactic.abel

/-!
# Uniform structure on topological groups

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file defines uniform groups and its additive counterpart. These typeclasses should be
preferred over using `[topological_space Œ±] [topological_group Œ±]` since every topological
group naturally induces a uniform structure.

## Main declarations
* `uniform_group` and `uniform_add_group`: Multiplicative and additive uniform groups, that
  i.e., groups with uniformly continuous `(*)` and `(‚Åª¬π)` / `(+)` and `(-)`.

## Main results

* `topological_add_group.to_uniform_space` and `topological_add_comm_group_is_uniform` can be used
  to construct a canonical uniformity for a topological add group.

* extension of ‚Ñ§-bilinear maps to complete groups (useful for ring completions)

* `quotient_group.complete_space` and `quotient_add_group.complete_space` guarantee that quotients
  of first countable topological groups by normal subgroups are themselves complete. In particular,
  the quotient of a Banach space by a subspace is complete.
-/

noncomputable theory
open_locale classical uniformity topology filter pointwise

section uniform_group
open filter set

variables {Œ± : Type*} {Œ≤ : Type*}

/-- A uniform group is a group in which multiplication and inversion are uniformly continuous. -/
class uniform_group (Œ± : Type*) [uniform_space Œ±] [group Œ±] : Prop :=
(uniform_continuous_div : uniform_continuous (Œªp:Œ±√óŒ±, p.1 / p.2))

/-- A uniform additive group is an additive group in which addition
  and negation are uniformly continuous.-/
class uniform_add_group (Œ± : Type*) [uniform_space Œ±] [add_group Œ±] : Prop :=
(uniform_continuous_sub : uniform_continuous (Œªp:Œ±√óŒ±, p.1 - p.2))

attribute [to_additive] uniform_group

@[to_additive] theorem uniform_group.mk' {Œ±} [uniform_space Œ±] [group Œ±]
  (h‚ÇÅ : uniform_continuous (Œªp:Œ±√óŒ±, p.1 * p.2))
  (h‚ÇÇ : uniform_continuous (Œªp:Œ±, p‚Åª¬π)) : uniform_group Œ± :=
‚ü®by simpa only [div_eq_mul_inv] using
  h‚ÇÅ.comp (uniform_continuous_fst.prod_mk (h‚ÇÇ.comp uniform_continuous_snd))‚ü©

variables [uniform_space Œ±] [group Œ±] [uniform_group Œ±]

@[to_additive] lemma uniform_continuous_div : uniform_continuous (Œªp:Œ±√óŒ±, p.1 / p.2) :=
uniform_group.uniform_continuous_div

@[to_additive] lemma uniform_continuous.div [uniform_space Œ≤] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±}
  (hf : uniform_continuous f) (hg : uniform_continuous g) : uniform_continuous (Œªx, f x / g x) :=
uniform_continuous_div.comp (hf.prod_mk hg)

@[to_additive] lemma uniform_continuous.inv [uniform_space Œ≤] {f : Œ≤ ‚Üí Œ±}
  (hf : uniform_continuous f) : uniform_continuous (Œªx, (f x)‚Åª¬π) :=
have uniform_continuous (Œªx, 1 / f x),
  from uniform_continuous_const.div hf,
by simp * at *

@[to_additive] lemma uniform_continuous_inv : uniform_continuous (Œªx:Œ±, x‚Åª¬π) :=
uniform_continuous_id.inv

@[to_additive] lemma uniform_continuous.mul [uniform_space Œ≤] {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ±}
  (hf : uniform_continuous f) (hg : uniform_continuous g) : uniform_continuous (Œªx, f x * g x) :=
have uniform_continuous (Œªx, f x / (g x)‚Åª¬π), from hf.div hg.inv,
by simp * at *

@[to_additive] lemma uniform_continuous_mul : uniform_continuous (Œªp:Œ±√óŒ±, p.1 * p.2) :=
uniform_continuous_fst.mul uniform_continuous_snd

@[to_additive uniform_continuous.const_nsmul]
lemma uniform_continuous.pow_const [uniform_space Œ≤] {f : Œ≤ ‚Üí Œ±}
  (hf : uniform_continuous f) : ‚àÄ n : ‚Ñï, uniform_continuous (Œª x, f x ^ n)
| 0 := by { simp_rw pow_zero, exact uniform_continuous_const }
| (n + 1) := by { simp_rw pow_succ, exact hf.mul (uniform_continuous.pow_const n) }

@[to_additive uniform_continuous_const_nsmul] lemma uniform_continuous_pow_const (n : ‚Ñï) :
  uniform_continuous (Œªx:Œ±, x ^ n) :=
uniform_continuous_id.pow_const n

@[to_additive uniform_continuous.const_zsmul]
lemma uniform_continuous.zpow_const [uniform_space Œ≤] {f : Œ≤ ‚Üí Œ±}
  (hf : uniform_continuous f) : ‚àÄ n : ‚Ñ§, uniform_continuous (Œª x, f x ^ n)
| (n : ‚Ñï) := by { simp_rw zpow_coe_nat, exact hf.pow_const _, }
| -[1+ n] := by { simp_rw zpow_neg_succ_of_nat, exact (hf.pow_const _).inv }

@[to_additive uniform_continuous_const_zsmul] lemma uniform_continuous_zpow_const (n : ‚Ñ§) :
  uniform_continuous (Œªx:Œ±, x ^ n) :=
uniform_continuous_id.zpow_const n

@[priority 10, to_additive]
instance uniform_group.to_topological_group : topological_group Œ± :=
{ continuous_mul := uniform_continuous_mul.continuous,
  continuous_inv := uniform_continuous_inv.continuous }

@[to_additive] instance [uniform_space Œ≤] [group Œ≤] [uniform_group Œ≤] : uniform_group (Œ± √ó Œ≤) :=
‚ü®((uniform_continuous_fst.comp uniform_continuous_fst).div
  (uniform_continuous_fst.comp uniform_continuous_snd)).prod_mk
 ((uniform_continuous_snd.comp uniform_continuous_fst).div
  (uniform_continuous_snd.comp uniform_continuous_snd))‚ü©

@[to_additive] lemma uniformity_translate_mul (a : Œ±) :
  (ùì§ Œ±).map (Œªx:Œ±√óŒ±, (x.1 * a, x.2 * a)) = ùì§ Œ± :=
le_antisymm
  (uniform_continuous_id.mul uniform_continuous_const)
  (calc ùì§ Œ± =
    ((ùì§ Œ±).map (Œªx:Œ±√óŒ±, (x.1 * a‚Åª¬π, x.2 * a‚Åª¬π))).map (Œªx:Œ±√óŒ±, (x.1 * a, x.2 * a)) :
      by simp [filter.map_map, (‚àò)]; exact filter.map_id.symm
    ... ‚â§ (ùì§ Œ±).map (Œªx:Œ±√óŒ±, (x.1 * a, x.2 * a)) :
      filter.map_mono (uniform_continuous_id.mul uniform_continuous_const))

@[to_additive] lemma uniform_embedding_translate_mul (a : Œ±) : uniform_embedding (Œªx:Œ±, x * a) :=
{ comap_uniformity := begin
    rw [‚Üê uniformity_translate_mul a, comap_map] {occs := occurrences.pos [1]},
    rintros ‚ü®p‚ÇÅ, p‚ÇÇ‚ü© ‚ü®q‚ÇÅ, q‚ÇÇ‚ü©,
    simp [prod.eq_iff_fst_eq_snd_eq] {contextual := tt}
  end,
  inj := mul_left_injective a }


namespace mul_opposite

@[to_additive] instance : uniform_group Œ±·µê·µí·µñ :=
‚ü®uniform_continuous_op.comp ((uniform_continuous_unop.comp uniform_continuous_snd).inv.mul $
  uniform_continuous_unop.comp uniform_continuous_fst)‚ü©

end mul_opposite

namespace subgroup

@[to_additive] instance (S : subgroup Œ±) : uniform_group S :=
‚ü®uniform_continuous_comap' (uniform_continuous_div.comp $
  uniform_continuous_subtype_val.prod_map uniform_continuous_subtype_val)‚ü©

end subgroup

section lattice_ops

variables [group Œ≤]

@[to_additive] lemma uniform_group_Inf {us : set (uniform_space Œ≤)}
  (h : ‚àÄ u ‚àà us, @uniform_group Œ≤ u _) :
  @uniform_group Œ≤ (Inf us) _ :=
{ uniform_continuous_div := uniform_continuous_Inf_rng (Œª u hu, uniform_continuous_Inf_dom‚ÇÇ hu hu
  (@uniform_group.uniform_continuous_div Œ≤ u _ (h u hu))) }

@[to_additive] lemma uniform_group_infi {Œπ : Sort*} {us' : Œπ ‚Üí uniform_space Œ≤}
  (h' : ‚àÄ i, @uniform_group Œ≤ (us' i) _) :
  @uniform_group Œ≤ (‚®Ö i, us' i) _ :=
by {rw ‚Üê Inf_range, exact uniform_group_Inf (set.forall_range_iff.mpr h')}

@[to_additive] lemma uniform_group_inf {u‚ÇÅ u‚ÇÇ : uniform_space Œ≤}
  (h‚ÇÅ : @uniform_group Œ≤ u‚ÇÅ _) (h‚ÇÇ : @uniform_group Œ≤ u‚ÇÇ _) :
  @uniform_group Œ≤ (u‚ÇÅ ‚äì u‚ÇÇ) _ :=
by {rw inf_eq_infi, refine uniform_group_infi (Œª b, _), cases b; assumption}

@[to_additive] lemma uniform_group_comap {Œ≥ : Type*} [group Œ≥] {u : uniform_space Œ≥}
  [uniform_group Œ≥] {F : Type*} [monoid_hom_class F Œ≤ Œ≥] (f : F) :
  @uniform_group Œ≤ (u.comap f) _ :=
{ uniform_continuous_div :=
    begin
      letI : uniform_space Œ≤ := u.comap f,
      refine uniform_continuous_comap' _,
      simp_rw [function.comp, map_div],
      change uniform_continuous ((Œª p : Œ≥ √ó Œ≥, p.1 / p.2) ‚àò (prod.map f f)),
      exact uniform_continuous_div.comp
        (uniform_continuous_comap.prod_map uniform_continuous_comap),
    end }

end lattice_ops

section
variables (Œ±)

@[to_additive] lemma uniformity_eq_comap_nhds_one : ùì§ Œ± = comap (Œªx:Œ±√óŒ±, x.2 / x.1) (ùìù (1:Œ±)) :=
begin
  rw [nhds_eq_comap_uniformity, filter.comap_comap],
  refine le_antisymm (filter.map_le_iff_le_comap.1 _) _,
  { assume s hs,
    rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_div hs
      with ‚ü®t, ht, hts‚ü©,
    refine mem_map.2 (mem_of_superset ht _),
    rintros ‚ü®a, b‚ü©,
    simpa [subset_def] using hts a b a },
  { assume s hs,
    rcases mem_uniformity_of_uniform_continuous_invariant uniform_continuous_mul hs
      with ‚ü®t, ht, hts‚ü©,
    refine ‚ü®_, ht, _‚ü©,
    rintros ‚ü®a, b‚ü©, simpa [subset_def] using hts 1 (b / a) a }
end

@[to_additive] lemma uniformity_eq_comap_nhds_one_swapped :
  ùì§ Œ± = comap (Œªx:Œ±√óŒ±, x.1 / x.2) (ùìù (1:Œ±)) :=
by { rw [‚Üê comap_swap_uniformity, uniformity_eq_comap_nhds_one, comap_comap, (‚àò)], refl }

@[to_additive] lemma uniform_group.ext {G : Type*} [group G] {u v : uniform_space G}
  (hu : @uniform_group G u _) (hv : @uniform_group G v _)
  (h : @nhds _ u.to_topological_space 1 = @nhds _ v.to_topological_space 1) :
  u = v :=
uniform_space_eq $
  by rw [@uniformity_eq_comap_nhds_one _ u _ hu, @uniformity_eq_comap_nhds_one _ v _ hv, h]

@[to_additive] lemma uniform_group.ext_iff {G : Type*} [group G] {u v : uniform_space G}
  (hu : @uniform_group G u _) (hv : @uniform_group G v _) :
  u = v ‚Üî @nhds _ u.to_topological_space 1 = @nhds _ v.to_topological_space 1 :=
‚ü®Œª h, h ‚ñ∏ rfl, hu.ext hv‚ü©

variables {Œ±}

@[to_additive] theorem uniform_group.uniformity_countably_generated
  [(ùìù (1 : Œ±)).is_countably_generated] :
  (ùì§ Œ±).is_countably_generated :=
by { rw uniformity_eq_comap_nhds_one, exact filter.comap.is_countably_generated _ _ }

open mul_opposite

@[to_additive]
lemma uniformity_eq_comap_inv_mul_nhds_one : ùì§ Œ± = comap (Œªx:Œ±√óŒ±, x.1‚Åª¬π * x.2) (ùìù (1:Œ±)) :=
begin
  rw [‚Üê comap_uniformity_mul_opposite, uniformity_eq_comap_nhds_one, ‚Üê op_one, ‚Üê comap_unop_nhds,
    comap_comap, comap_comap],
  simp [(‚àò)]
end

@[to_additive] lemma uniformity_eq_comap_inv_mul_nhds_one_swapped :
  ùì§ Œ± = comap (Œªx:Œ±√óŒ±, x.2‚Åª¬π * x.1) (ùìù (1:Œ±)) :=
by { rw [‚Üê comap_swap_uniformity, uniformity_eq_comap_inv_mul_nhds_one, comap_comap, (‚àò)], refl }

end

@[to_additive] lemma filter.has_basis.uniformity_of_nhds_one {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí set Œ±}
  (h : (ùìù (1 : Œ±)).has_basis p U) :
  (ùì§ Œ±).has_basis p (Œª i, {x : Œ± √ó Œ± | x.2 / x.1 ‚àà U i}) :=
by { rw uniformity_eq_comap_nhds_one, exact h.comap _ }

@[to_additive] lemma filter.has_basis.uniformity_of_nhds_one_inv_mul
  {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí set Œ±} (h : (ùìù (1 : Œ±)).has_basis p U) :
  (ùì§ Œ±).has_basis p (Œª i, {x : Œ± √ó Œ± | x.1‚Åª¬π * x.2 ‚àà U i}) :=
by { rw uniformity_eq_comap_inv_mul_nhds_one, exact h.comap _ }

@[to_additive] lemma filter.has_basis.uniformity_of_nhds_one_swapped
  {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí set Œ±} (h : (ùìù (1 : Œ±)).has_basis p U) :
  (ùì§ Œ±).has_basis p (Œª i, {x : Œ± √ó Œ± | x.1 / x.2 ‚àà U i}) :=
by { rw uniformity_eq_comap_nhds_one_swapped, exact h.comap _ }

@[to_additive] lemma filter.has_basis.uniformity_of_nhds_one_inv_mul_swapped
  {Œπ} {p : Œπ ‚Üí Prop} {U : Œπ ‚Üí set Œ±} (h : (ùìù (1 : Œ±)).has_basis p U) :
  (ùì§ Œ±).has_basis p (Œª i, {x : Œ± √ó Œ± | x.2‚Åª¬π * x.1 ‚àà U i}) :=
by { rw uniformity_eq_comap_inv_mul_nhds_one_swapped, exact h.comap _ }

@[to_additive] lemma group_separation_rel (x y : Œ±) :
  (x, y) ‚àà separation_rel Œ± ‚Üî x / y ‚àà closure ({1} : set Œ±) :=
have embedding (Œªa, a * (y / x)), from (uniform_embedding_translate_mul (y / x)).embedding,
show (x, y) ‚àà ‚ãÇ‚ÇÄ (ùì§ Œ±).sets ‚Üî x / y ‚àà closure ({1} : set Œ±),
begin
  rw [this.closure_eq_preimage_closure_image, uniformity_eq_comap_nhds_one Œ±, sInter_comap_sets],
  simp [mem_closure_iff_nhds, inter_singleton_nonempty, sub_eq_add_neg, add_assoc]
end

@[to_additive] lemma uniform_continuous_of_tendsto_one {hom : Type*} [uniform_space Œ≤] [group Œ≤]
  [uniform_group Œ≤] [monoid_hom_class hom Œ± Œ≤] {f : hom} (h : tendsto f (ùìù 1) (ùìù 1)) :
  uniform_continuous f :=
begin
  have : ((Œªx:Œ≤√óŒ≤, x.2 / x.1) ‚àò (Œªx:Œ±√óŒ±, (f x.1, f x.2))) = (Œªx:Œ±√óŒ±, f (x.2 / x.1)),
  { simp only [map_div] },
  rw [uniform_continuous, uniformity_eq_comap_nhds_one Œ±, uniformity_eq_comap_nhds_one Œ≤,
    tendsto_comap_iff, this],
  exact tendsto.comp h tendsto_comap
end

/-- A group homomorphism (a bundled morphism of a type that implements `monoid_hom_class`) between
two uniform groups is uniformly continuous provided that it is continuous at one. See also
`continuous_of_continuous_at_one`. -/
@[to_additive "An additive group homomorphism (a bundled morphism of a type that implements
`add_monoid_hom_class`) between two uniform additive groups is uniformly continuous provided that it
is continuous at zero. See also `continuous_of_continuous_at_zero`."]
lemma uniform_continuous_of_continuous_at_one {hom : Type*}
  [uniform_space Œ≤] [group Œ≤] [uniform_group Œ≤] [monoid_hom_class hom Œ± Œ≤]
  (f : hom) (hf : continuous_at f 1) :
  uniform_continuous f :=
uniform_continuous_of_tendsto_one (by simpa using hf.tendsto)

@[to_additive] lemma monoid_hom.uniform_continuous_of_continuous_at_one
  [uniform_space Œ≤] [group Œ≤] [uniform_group Œ≤]
  (f : Œ± ‚Üí* Œ≤) (hf : continuous_at f 1) :
  uniform_continuous f :=
uniform_continuous_of_continuous_at_one f hf

/-- A homomorphism from a uniform group to a discrete uniform group is continuous if and only if
its kernel is open. -/
@[to_additive "A homomorphism from a uniform additive group to a discrete uniform additive group is
continuous if and only if its kernel is open."]
lemma uniform_group.uniform_continuous_iff_open_ker {hom : Type*} [uniform_space Œ≤]
  [discrete_topology Œ≤] [group Œ≤] [uniform_group Œ≤] [monoid_hom_class hom Œ± Œ≤] {f : hom} :
  uniform_continuous f ‚Üî is_open ((f : Œ± ‚Üí* Œ≤).ker : set Œ±) :=
begin
  refine ‚ü®Œª hf, _, Œª hf, _‚ü©,
  { apply (is_open_discrete ({1} : set Œ≤)).preimage (uniform_continuous.continuous hf) },
  { apply uniform_continuous_of_continuous_at_one,
    rw [continuous_at, nhds_discrete Œ≤, map_one, tendsto_pure],
    exact hf.mem_nhds (map_one f) }
end

@[to_additive] lemma uniform_continuous_monoid_hom_of_continuous {hom : Type*} [uniform_space Œ≤]
  [group Œ≤] [uniform_group Œ≤] [monoid_hom_class hom Œ± Œ≤] {f : hom} (h : continuous f) :
  uniform_continuous f :=
uniform_continuous_of_tendsto_one $
  suffices tendsto f (ùìù 1) (ùìù (f 1)), by rwa map_one at this,
  h.tendsto 1

@[to_additive] lemma cauchy_seq.mul {Œπ : Type*} [semilattice_sup Œπ] {u v : Œπ ‚Üí Œ±}
  (hu : cauchy_seq u) (hv : cauchy_seq v) : cauchy_seq (u * v) :=
uniform_continuous_mul.comp_cauchy_seq (hu.prod hv)

@[to_additive] lemma cauchy_seq.mul_const {Œπ : Type*} [semilattice_sup Œπ]
  {u : Œπ ‚Üí Œ±} {x : Œ±} (hu : cauchy_seq u) : cauchy_seq (Œª n, u n * x) :=
(uniform_continuous_id.mul uniform_continuous_const).comp_cauchy_seq hu

@[to_additive] lemma cauchy_seq.const_mul {Œπ : Type*} [semilattice_sup Œπ]
  {u : Œπ ‚Üí Œ±} {x : Œ±} (hu : cauchy_seq u) : cauchy_seq (Œª n, x * u n) :=
(uniform_continuous_const.mul uniform_continuous_id).comp_cauchy_seq hu

@[to_additive] lemma cauchy_seq.inv {Œπ : Type*} [semilattice_sup Œπ]
  {u : Œπ ‚Üí Œ±} (h : cauchy_seq u) : cauchy_seq (u‚Åª¬π) :=
uniform_continuous_inv.comp_cauchy_seq h

@[to_additive] lemma totally_bounded_iff_subset_finite_Union_nhds_one {s : set Œ±} :
  totally_bounded s ‚Üî ‚àÄ U ‚àà ùìù (1 : Œ±), ‚àÉ (t : set Œ±), t.finite ‚àß s ‚äÜ ‚ãÉ y ‚àà t, y ‚Ä¢ U :=
(ùìù (1 : Œ±)).basis_sets.uniformity_of_nhds_one_inv_mul_swapped.totally_bounded_iff.trans $
  by simp [‚Üê preimage_smul_inv, preimage]

section uniform_convergence
variables {Œπ : Type*} {l : filter Œπ} {l' : filter Œ≤} {f f' : Œπ ‚Üí Œ≤ ‚Üí Œ±} {g g' : Œ≤ ‚Üí Œ±} {s : set Œ≤}

@[to_additive] lemma tendsto_uniformly_on_filter.mul (hf : tendsto_uniformly_on_filter f g l l')
  (hf' : tendsto_uniformly_on_filter f' g' l l') :
  tendsto_uniformly_on_filter (f * f') (g * g') l l' :=
Œª u hu, ((uniform_continuous_mul.comp_tendsto_uniformly_on_filter
  (hf.prod hf')) u hu).diag_of_prod_left

@[to_additive] lemma tendsto_uniformly_on_filter.div (hf : tendsto_uniformly_on_filter f g l l')
  (hf' : tendsto_uniformly_on_filter f' g' l l') :
  tendsto_uniformly_on_filter (f / f') (g / g') l l' :=
Œª u hu, ((uniform_continuous_div.comp_tendsto_uniformly_on_filter
  (hf.prod hf')) u hu).diag_of_prod_left

@[to_additive] lemma tendsto_uniformly_on.mul (hf : tendsto_uniformly_on f g l s)
  (hf' : tendsto_uniformly_on f' g' l s) : tendsto_uniformly_on (f * f') (g * g') l s :=
Œª u hu, ((uniform_continuous_mul.comp_tendsto_uniformly_on (hf.prod hf')) u hu).diag_of_prod

@[to_additive] lemma tendsto_uniformly_on.div (hf : tendsto_uniformly_on f g l s)
  (hf' : tendsto_uniformly_on f' g' l s) : tendsto_uniformly_on (f / f') (g / g') l s :=
Œª u hu, ((uniform_continuous_div.comp_tendsto_uniformly_on (hf.prod hf')) u hu).diag_of_prod

@[to_additive] lemma tendsto_uniformly.mul (hf : tendsto_uniformly f g l)
  (hf' : tendsto_uniformly f' g' l) : tendsto_uniformly (f * f') (g * g') l :=
Œª u hu, ((uniform_continuous_mul.comp_tendsto_uniformly (hf.prod hf')) u hu).diag_of_prod

@[to_additive] lemma tendsto_uniformly.div (hf : tendsto_uniformly f g l)
  (hf' : tendsto_uniformly f' g' l) : tendsto_uniformly (f / f') (g / g') l :=
Œª u hu, ((uniform_continuous_div.comp_tendsto_uniformly (hf.prod hf')) u hu).diag_of_prod

@[to_additive] lemma uniform_cauchy_seq_on.mul (hf : uniform_cauchy_seq_on f l s)
  (hf' : uniform_cauchy_seq_on f' l s) : uniform_cauchy_seq_on (f * f') l s :=
Œª u hu, by simpa using ((uniform_continuous_mul.comp_uniform_cauchy_seq_on (hf.prod' hf')) u hu)

@[to_additive] lemma uniform_cauchy_seq_on.div (hf : uniform_cauchy_seq_on f l s)
  (hf' : uniform_cauchy_seq_on f' l s) : uniform_cauchy_seq_on (f / f') l s :=
Œª u hu, by simpa using ((uniform_continuous_div.comp_uniform_cauchy_seq_on (hf.prod' hf')) u hu)

end uniform_convergence
end uniform_group

section topological_group
open filter
variables (G : Type*) [group G] [topological_space G] [topological_group G]

/-- The right uniformity on a topological group (as opposed to the left uniformity).

Warning: in general the right and left uniformities do not coincide and so one does not obtain a
`uniform_group` structure. Two important special cases where they _do_ coincide are for
commutative groups (see `topological_comm_group_is_uniform`) and for compact groups (see
`topological_group_is_uniform_of_compact_space`). -/
@[to_additive "The right uniformity on a topological additive group (as opposed to the left
uniformity).

Warning: in general the right and left uniformities do not coincide and so one does not obtain a
`uniform_add_group` structure. Two important special cases where they _do_ coincide are for
commutative additive groups (see `topological_add_comm_group_is_uniform`) and for compact
additive groups (see `topological_add_comm_group_is_uniform_of_compact_space`)."]
def topological_group.to_uniform_space : uniform_space G :=
{ uniformity          := comap (Œªp:G√óG, p.2 / p.1) (ùìù 1),
  refl                :=
    by refine map_le_iff_le_comap.1 (le_trans _ (pure_le_nhds 1));
      simp [set.subset_def] {contextual := tt},
  symm                :=
  begin
    suffices : tendsto (Œªp:G√óG, (p.2 / p.1)‚Åª¬π) (comap (Œªp:G√óG, p.2 / p.1) (ùìù 1)) (ùìù 1‚Åª¬π),
    { simpa [tendsto_comap_iff], },
    exact tendsto.comp (tendsto.inv tendsto_id) tendsto_comap
  end,
  comp                :=
  begin
    intros D H,
    rw mem_lift'_sets,
    { rcases H with ‚ü®U, U_nhds, U_sub‚ü©,
      rcases exists_nhds_one_split U_nhds with ‚ü®V, ‚ü®V_nhds, V_sum‚ü©‚ü©,
      existsi ((Œªp:G√óG, p.2 / p.1) ‚Åª¬π' V),
      have H : (Œªp:G√óG, p.2 / p.1) ‚Åª¬π' V ‚àà comap (Œªp:G√óG, p.2 / p.1) (ùìù (1 : G)),
        by existsi [V, V_nhds] ; refl,
      existsi H,
      have comp_rel_sub :
        comp_rel ((Œªp:G√óG, p.2 / p.1) ‚Åª¬π' V) ((Œªp, p.2 / p.1) ‚Åª¬π' V) ‚äÜ (Œªp:G√óG, p.2 / p.1) ‚Åª¬π' U,
      begin
        intros p p_comp_rel,
        rcases p_comp_rel with ‚ü®z, ‚ü®Hz1, Hz2‚ü©‚ü©,
        simpa using V_sum _ Hz2 _ Hz1,
      end,
      exact set.subset.trans comp_rel_sub U_sub },
    { exact monotone_id.comp_rel monotone_id }
  end,
  is_open_uniformity  :=
  begin
    intro S,
    let S' := Œª x, {p : G √ó G | p.1 = x ‚Üí p.2 ‚àà S},
    show is_open S ‚Üî ‚àÄ (x : G), x ‚àà S ‚Üí S' x ‚àà comap (Œªp:G√óG, p.2 / p.1) (ùìù (1 : G)),
    rw [is_open_iff_mem_nhds],
    refine forall‚ÇÇ_congr (Œª a ha, _),
    rw [‚Üê nhds_translation_div, mem_comap, mem_comap],
    refine exists‚ÇÇ_congr (Œª t ht, _),
    show (Œª (y : G), y / a) ‚Åª¬π' t ‚äÜ S ‚Üî (Œª (p : G √ó G), p.snd / p.fst) ‚Åª¬π' t ‚äÜ S' a,
    split,
    { rintros h ‚ü®x, y‚ü© hx rfl, exact h hx },
    { rintros h x hx, exact @h (a, x) hx rfl }
  end }

local attribute [instance] topological_group.to_uniform_space

@[to_additive] lemma uniformity_eq_comap_nhds_one' :
  ùì§ G = comap (Œªp:G√óG, p.2 / p.1) (ùìù (1 : G)) := rfl

@[to_additive] lemma topological_group_is_uniform_of_compact_space
  [compact_space G] : uniform_group G :=
‚ü®begin
  apply compact_space.uniform_continuous_of_continuous,
  exact continuous_div',
end‚ü©

variables {G}

@[to_additive] instance subgroup.is_closed_of_discrete [t2_space G]
  {H : subgroup G} [discrete_topology H] : is_closed (H : set G) :=
begin
  obtain ‚ü®V, V_in, VH‚ü© : ‚àÉ (V : set G) (hV : V ‚àà ùìù (1 : G)), V ‚à© (H : set G) = {1},
    from nhds_inter_eq_singleton_of_mem_discrete H.one_mem,
  haveI : separated_space G := separated_iff_t2.mpr ‚Äπ_‚Ä∫,
  have : (Œª p : G √ó G, p.2 / p.1) ‚Åª¬π' V ‚àà ùì§ G, from preimage_mem_comap V_in,
  apply is_closed_of_spaced_out this,
  intros h h_in h' h'_in,
  contrapose!,
  rintro (hyp : h' / h ‚àà V),
  have : h'/h ‚àà ({1} : set G) := VH ‚ñ∏ set.mem_inter hyp (H.div_mem h'_in h_in),
  exact (eq_of_div_eq_one this).symm
end

@[to_additive] lemma topological_group.tendsto_uniformly_iff
  {Œπ Œ± : Type*} (F : Œπ ‚Üí Œ± ‚Üí G) (f : Œ± ‚Üí G) (p : filter Œπ) :
  @tendsto_uniformly Œ± G Œπ (topological_group.to_uniform_space G) F f p
    ‚Üî ‚àÄ u ‚àà ùìù (1 : G), ‚àÄ·∂† i in p, ‚àÄ a, F i a / f a ‚àà u :=
‚ü®Œª h u hu, h _ ‚ü®u, hu, Œª _, id‚ü©, Œª h v ‚ü®u, hu, hv‚ü©,
  mem_of_superset (h u hu) (Œª i hi a, hv (by exact hi a))‚ü©

@[to_additive] lemma topological_group.tendsto_uniformly_on_iff
  {Œπ Œ± : Type*} (F : Œπ ‚Üí Œ± ‚Üí G) (f : Œ± ‚Üí G) (p : filter Œπ) (s : set Œ±) :
  @tendsto_uniformly_on Œ± G Œπ (topological_group.to_uniform_space G) F f p s
    ‚Üî ‚àÄ u ‚àà ùìù (1 : G), ‚àÄ·∂† i in p, ‚àÄ a ‚àà s, F i a / f a ‚àà u :=
‚ü®Œª h u hu, h _ ‚ü®u, hu, Œª _, id‚ü©, Œª h v ‚ü®u, hu, hv‚ü©,
  mem_of_superset (h u hu) (Œª i hi a ha, hv (by exact hi a ha))‚ü©

@[to_additive] lemma topological_group.tendsto_locally_uniformly_iff
  {Œπ Œ± : Type*} [topological_space Œ±] (F : Œπ ‚Üí Œ± ‚Üí G) (f : Œ± ‚Üí G) (p : filter Œπ) :
  @tendsto_locally_uniformly Œ± G Œπ (topological_group.to_uniform_space G) _ F f p
    ‚Üî ‚àÄ (u ‚àà ùìù (1 : G)) (x : Œ±), ‚àÉ (t ‚àà ùìù x), ‚àÄ·∂† i in p, ‚àÄ a ‚àà t, F i a / f a ‚àà u :=
‚ü®Œª h u hu, h _ ‚ü®u, hu, Œª _, id‚ü©, Œª h v ‚ü®u, hu, hv‚ü© x, exists_imp_exists (by exact Œª a,
  exists_imp_exists (Œª ha hp, mem_of_superset hp (Œª i hi a ha, hv (by exact hi a ha)))) (h u hu x)‚ü©

@[to_additive] lemma topological_group.tendsto_locally_uniformly_on_iff
  {Œπ Œ± : Type*} [topological_space Œ±] (F : Œπ ‚Üí Œ± ‚Üí G) (f : Œ± ‚Üí G) (p : filter Œπ) (s : set Œ±) :
  @tendsto_locally_uniformly_on Œ± G Œπ (topological_group.to_uniform_space G) _ F f p s
    ‚Üî ‚àÄ (u ‚àà ùìù (1 : G)) (x ‚àà s), ‚àÉ (t ‚àà ùìù[s] x), ‚àÄ·∂† i in p, ‚àÄ a ‚àà t, F i a / f a ‚àà u :=
‚ü®Œª h u hu, h _ ‚ü®u, hu, Œª _, id‚ü©, Œª h v ‚ü®u, hu, hv‚ü© x, exists_imp_exists (by exact Œª a,
  exists_imp_exists (Œª ha hp, mem_of_superset hp (Œª i hi a ha, hv (by exact hi a ha)))) ‚àò h u hu x‚ü©

end topological_group

section topological_comm_group
universes u v w x
open filter

variables (G : Type*) [comm_group G] [topological_space G] [topological_group G]

section
local attribute [instance] topological_group.to_uniform_space

variable {G}
@[to_additive] lemma topological_comm_group_is_uniform : uniform_group G :=
have tendsto
    ((Œªp:(G√óG), p.1 / p.2) ‚àò (Œªp:(G√óG)√ó(G√óG), (p.1.2 / p.1.1, p.2.2 / p.2.1)))
    (comap (Œªp:(G√óG)√ó(G√óG), (p.1.2 / p.1.1, p.2.2 / p.2.1)) ((ùìù 1).prod (ùìù 1)))
    (ùìù (1 / 1)) :=
  (tendsto_fst.div' tendsto_snd).comp tendsto_comap,
begin
  constructor,
  rw [uniform_continuous, uniformity_prod_eq_prod, tendsto_map'_iff,
    uniformity_eq_comap_nhds_one' G, tendsto_comap_iff, prod_comap_comap_eq],
  simpa [(‚àò), div_eq_mul_inv, mul_comm, mul_left_comm] using this
end

open set

@[to_additive] lemma topological_group.t2_space_iff_one_closed :
  t2_space G ‚Üî is_closed ({1} : set G) :=
begin
  haveI : uniform_group G := topological_comm_group_is_uniform,
  rw [‚Üê separated_iff_t2, separated_space_iff, ‚Üê closure_eq_iff_is_closed],
  split; intro h,
  { apply subset.antisymm,
    { intros x x_in,
      have := group_separation_rel x 1,
      rw div_one at this,
      rw [‚Üê this, h] at x_in,
      change x = 1 at x_in,
      simp [x_in] },
    { exact subset_closure } },
  { ext p,
    cases p with x y,
    rw [group_separation_rel x, h, mem_singleton_iff, div_eq_one],
    refl }
end

@[to_additive] lemma topological_group.t2_space_of_one_sep
  (H : ‚àÄ x : G, x ‚â† 1 ‚Üí ‚àÉ U ‚àà nhds (1 : G), x ‚àâ U) : t2_space G :=
begin
  rw [topological_group.t2_space_iff_one_closed, ‚Üê is_open_compl_iff, is_open_iff_mem_nhds],
  intros x x_not,
  have : x ‚â† 1, from mem_compl_singleton_iff.mp x_not,
  rcases H x this with ‚ü®U, U_in, xU‚ü©,
  rw ‚Üê nhds_one_symm G at U_in,
  rcases U_in with ‚ü®W, W_in, UW‚ü©,
  rw ‚Üê nhds_translation_mul_inv,
  use [W, W_in],
  rw subset_compl_comm,
  suffices : x‚Åª¬π ‚àâ W, by simpa,
  exact Œª h, xU (UW h)
end

end

@[to_additive] lemma uniform_group.to_uniform_space_eq {G : Type*} [u : uniform_space G]
  [group G] [uniform_group G] : topological_group.to_uniform_space G = u :=
begin
  ext : 1,
  rw [uniformity_eq_comap_nhds_one' G, uniformity_eq_comap_nhds_one G]
end

end topological_comm_group

open filter set function

section
variables {Œ± : Type*} {Œ≤ : Type*} {hom : Type*}
variables [topological_space Œ±] [group Œ±] [topological_group Œ±]

-- Œ≤ is a dense subgroup of Œ±, inclusion is denoted by e
variables [topological_space Œ≤] [group Œ≤]
variables [monoid_hom_class hom Œ≤ Œ±] {e : hom} (de : dense_inducing e)
include de

@[to_additive] lemma tendsto_div_comap_self (x‚ÇÄ : Œ±) :
  tendsto (Œªt:Œ≤√óŒ≤, t.2 / t.1) (comap (Œªp:Œ≤√óŒ≤, (e p.1, e p.2)) $ ùìù (x‚ÇÄ, x‚ÇÄ)) (ùìù 1) :=
begin
  have comm : (Œªx:Œ±√óŒ±, x.2/x.1) ‚àò (Œªt:Œ≤√óŒ≤, (e t.1, e t.2)) = e ‚àò (Œªt:Œ≤√óŒ≤, t.2 / t.1),
  { ext t,
    change e t.2 / e t.1 = e (t.2 / t.1),
    rwa ‚Üê map_div e t.2 t.1 },
  have lim : tendsto (Œª x : Œ± √ó Œ±, x.2/x.1) (ùìù (x‚ÇÄ, x‚ÇÄ)) (ùìù (e 1)),
  { simpa using (continuous_div'.comp (@continuous_swap Œ± Œ± _ _)).tendsto (x‚ÇÄ, x‚ÇÄ) },
  simpa using de.tendsto_comap_nhds_nhds lim comm
end
end

namespace dense_inducing
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œ¥ : Type*}
variables {G : Type*}

-- Œ≤ is a dense subgroup of Œ±, inclusion is denoted by e
-- Œ¥ is a dense subgroup of Œ≥, inclusion is denoted by f
variables [topological_space Œ±] [add_comm_group Œ±] [topological_add_group Œ±]
variables [topological_space Œ≤] [add_comm_group Œ≤] [topological_add_group Œ≤]
variables [topological_space Œ≥] [add_comm_group Œ≥] [topological_add_group Œ≥]
variables [topological_space Œ¥] [add_comm_group Œ¥] [topological_add_group Œ¥]
variables [uniform_space G] [add_comm_group G] [uniform_add_group G] [separated_space G]
  [complete_space G]
variables {e : Œ≤ ‚Üí+ Œ±} (de : dense_inducing e)
variables {f : Œ¥ ‚Üí+ Œ≥} (df : dense_inducing f)

variables {œÜ : Œ≤ ‚Üí+ Œ¥ ‚Üí+ G}
local notation `Œ¶` := Œª p : Œ≤ √ó Œ¥, œÜ p.1 p.2

variables  (hœÜ : continuous Œ¶)

include de df hœÜ

variables {W' : set G} (W'_nhd : W' ‚àà ùìù (0 : G))
include W'_nhd

private lemma extend_Z_bilin_aux (x‚ÇÄ : Œ±) (y‚ÇÅ : Œ¥) :
  ‚àÉ U‚ÇÇ ‚àà comap e (ùìù x‚ÇÄ), ‚àÄ x x' ‚àà U‚ÇÇ, Œ¶ (x' - x, y‚ÇÅ) ‚àà W' :=
begin
  let Nx := ùìù x‚ÇÄ,
  let ee := Œª u : Œ≤ √ó Œ≤, (e u.1, e u.2),

  have lim1 : tendsto (Œª a : Œ≤ √ó Œ≤, (a.2 - a.1, y‚ÇÅ)) (comap e Nx √ó·∂† comap e Nx) (ùìù (0, y‚ÇÅ)),
  { have := tendsto.prod_mk (tendsto_sub_comap_self de x‚ÇÄ)
      (tendsto_const_nhds : tendsto (Œª (p : Œ≤ √ó Œ≤), y‚ÇÅ) (comap ee $ ùìù (x‚ÇÄ, x‚ÇÄ)) (ùìù y‚ÇÅ)),
    rw [nhds_prod_eq, prod_comap_comap_eq, ‚Üênhds_prod_eq],
    exact (this : _) },
  have lim2 : tendsto Œ¶ (ùìù (0, y‚ÇÅ)) (ùìù 0), by simpa using hœÜ.tendsto (0, y‚ÇÅ),
  have lim := lim2.comp lim1,
  rw tendsto_prod_self_iff at lim,
  simp_rw ball_mem_comm,
  exact lim W' W'_nhd
end

private lemma extend_Z_bilin_key (x‚ÇÄ : Œ±) (y‚ÇÄ : Œ≥) :
  ‚àÉ U ‚àà comap e (ùìù x‚ÇÄ), ‚àÉ V ‚àà comap f (ùìù y‚ÇÄ),
    ‚àÄ x x' ‚àà U, ‚àÄ y y' ‚àà V, Œ¶ (x', y') - Œ¶ (x, y) ‚àà W' :=
begin
  let Nx := ùìù x‚ÇÄ,
  let Ny := ùìù y‚ÇÄ,
  let dp := dense_inducing.prod de df,
  let ee := Œª u : Œ≤ √ó Œ≤, (e u.1, e u.2),
  let ff := Œª u : Œ¥ √ó Œ¥, (f u.1, f u.2),

  have lim_œÜ : filter.tendsto Œ¶ (ùìù (0, 0)) (ùìù 0),
  { simpa using hœÜ.tendsto (0, 0) },

  have lim_œÜ_sub_sub : tendsto (Œª (p : (Œ≤ √ó Œ≤) √ó (Œ¥ √ó Œ¥)), Œ¶ (p.1.2 - p.1.1, p.2.2 - p.2.1))
    ((comap ee $ ùìù (x‚ÇÄ, x‚ÇÄ)) √ó·∂† (comap ff $ ùìù (y‚ÇÄ, y‚ÇÄ))) (ùìù 0),
  { have lim_sub_sub :  tendsto (Œª (p : (Œ≤ √ó Œ≤) √ó Œ¥ √ó Œ¥), (p.1.2 - p.1.1, p.2.2 - p.2.1))
      ((comap ee (ùìù (x‚ÇÄ, x‚ÇÄ))) √ó·∂† (comap ff (ùìù (y‚ÇÄ, y‚ÇÄ)))) (ùìù 0 √ó·∂† ùìù 0),
    { have := filter.prod_mono (tendsto_sub_comap_self de x‚ÇÄ) (tendsto_sub_comap_self df y‚ÇÄ),
      rwa prod_map_map_eq at this },
    rw ‚Üê nhds_prod_eq at lim_sub_sub,
    exact tendsto.comp lim_œÜ lim_sub_sub },

  rcases exists_nhds_zero_quarter W'_nhd with ‚ü®W, W_nhd, W4‚ü©,

  have : ‚àÉ U‚ÇÅ ‚àà comap e (ùìù x‚ÇÄ), ‚àÉ V‚ÇÅ ‚àà comap f (ùìù y‚ÇÄ),
    ‚àÄ x x' ‚àà U‚ÇÅ, ‚àÄ y y' ‚àà V‚ÇÅ,  Œ¶ (x'-x, y'-y) ‚àà W,
  { have := tendsto_prod_iff.1 lim_œÜ_sub_sub W W_nhd,
    repeat { rw [nhds_prod_eq, ‚Üêprod_comap_comap_eq] at this },
    rcases this with ‚ü®U, U_in, V, V_in, H‚ü©,
    rw [mem_prod_same_iff] at U_in V_in,
    rcases U_in with ‚ü®U‚ÇÅ, U‚ÇÅ_in, HU‚ÇÅ‚ü©,
    rcases V_in with ‚ü®V‚ÇÅ, V‚ÇÅ_in, HV‚ÇÅ‚ü©,
    existsi [U‚ÇÅ, U‚ÇÅ_in, V‚ÇÅ, V‚ÇÅ_in],
    intros x x_in x' x'_in y y_in y' y'_in,
    exact H _ _ (HU‚ÇÅ (mk_mem_prod x_in x'_in)) (HV‚ÇÅ (mk_mem_prod y_in y'_in)) },
  rcases this with ‚ü®U‚ÇÅ, U‚ÇÅ_nhd, V‚ÇÅ, V‚ÇÅ_nhd, H‚ü©,

  obtain ‚ü®x‚ÇÅ, x‚ÇÅ_in‚ü© : U‚ÇÅ.nonempty :=
    ((de.comap_nhds_ne_bot _).nonempty_of_mem U‚ÇÅ_nhd),
  obtain ‚ü®y‚ÇÅ, y‚ÇÅ_in‚ü© : V‚ÇÅ.nonempty :=
    ((df.comap_nhds_ne_bot _).nonempty_of_mem V‚ÇÅ_nhd),

  have cont_flip : continuous (Œª p : Œ¥ √ó Œ≤, œÜ.flip p.1 p.2),
  { show continuous (Œ¶ ‚àò prod.swap), from hœÜ.comp continuous_swap },
  rcases (extend_Z_bilin_aux de df hœÜ W_nhd x‚ÇÄ y‚ÇÅ) with ‚ü®U‚ÇÇ, U‚ÇÇ_nhd, HU‚ü©,
  rcases (extend_Z_bilin_aux df de cont_flip W_nhd y‚ÇÄ x‚ÇÅ) with ‚ü®V‚ÇÇ, V‚ÇÇ_nhd, HV‚ü©,

  existsi [U‚ÇÅ ‚à© U‚ÇÇ, inter_mem U‚ÇÅ_nhd U‚ÇÇ_nhd,
            V‚ÇÅ ‚à© V‚ÇÇ, inter_mem V‚ÇÅ_nhd V‚ÇÇ_nhd],

  rintros x ‚ü®xU‚ÇÅ, xU‚ÇÇ‚ü© x' ‚ü®x'U‚ÇÅ, x'U‚ÇÇ‚ü© y ‚ü®yV‚ÇÅ, yV‚ÇÇ‚ü© y' ‚ü®y'V‚ÇÅ, y'V‚ÇÇ‚ü©,
  have key_formula : œÜ x' y' - œÜ x y =
    œÜ(x' - x) y‚ÇÅ + œÜ (x' - x) (y' - y‚ÇÅ) + œÜ x‚ÇÅ (y' - y) + œÜ (x - x‚ÇÅ) (y' - y),
  { simp, abel },
  rw key_formula,
  have h‚ÇÅ := HU x xU‚ÇÇ x' x'U‚ÇÇ,
  have h‚ÇÇ := H x xU‚ÇÅ x' x'U‚ÇÅ y‚ÇÅ y‚ÇÅ_in y' y'V‚ÇÅ,
  have h‚ÇÉ := HV y yV‚ÇÇ y' y'V‚ÇÇ,
  have h‚ÇÑ := H x‚ÇÅ x‚ÇÅ_in x xU‚ÇÅ y yV‚ÇÅ y' y'V‚ÇÅ,
  exact W4 h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ
end

omit W'_nhd

open dense_inducing

/-- Bourbaki GT III.6.5 Theorem I:
‚Ñ§-bilinear continuous maps from dense images into a complete Hausdorff group extend by continuity.
Note: Bourbaki assumes that Œ± and Œ≤ are also complete Hausdorff, but this is not necessary. -/
theorem extend_Z_bilin  : continuous (extend (de.prod df) Œ¶) :=
begin
  refine continuous_extend_of_cauchy _ _,
  rintro ‚ü®x‚ÇÄ, y‚ÇÄ‚ü©,
  split,
  { apply ne_bot.map,
    apply comap_ne_bot,

    intros U h,
    rcases mem_closure_iff_nhds.1 ((de.prod df).dense (x‚ÇÄ, y‚ÇÄ)) U h with ‚ü®x, x_in, ‚ü®z, z_x‚ü©‚ü©,
    existsi z,
    cc },
  { suffices : map (Œª (p : (Œ≤ √ó Œ¥) √ó (Œ≤ √ó Œ¥)), Œ¶ p.2 - Œ¶ p.1)
      (comap (Œª (p : (Œ≤ √ó Œ¥) √ó Œ≤ √ó Œ¥), ((e p.1.1, f p.1.2), (e p.2.1, f p.2.2)))
         (ùìù (x‚ÇÄ, y‚ÇÄ) √ó·∂† ùìù (x‚ÇÄ, y‚ÇÄ))) ‚â§ ùìù 0,
    by rwa [uniformity_eq_comap_nhds_zero G, prod_map_map_eq, ‚Üêmap_le_iff_le_comap, filter.map_map,
        prod_comap_comap_eq],

    intros W' W'_nhd,

    have key := extend_Z_bilin_key de df hœÜ W'_nhd x‚ÇÄ y‚ÇÄ,
    rcases key with ‚ü®U, U_nhd, V, V_nhd, h‚ü©,
    rw mem_comap at U_nhd,
    rcases U_nhd with ‚ü®U', U'_nhd, U'_sub‚ü©,
    rw mem_comap at V_nhd,
    rcases V_nhd with ‚ü®V', V'_nhd, V'_sub‚ü©,

    rw [mem_map, mem_comap, nhds_prod_eq],
    existsi (U' √óÀ¢ V') √óÀ¢ (U' √óÀ¢ V'),
    rw mem_prod_same_iff,

    simp only [exists_prop],
    split,
    { change U' ‚àà ùìù x‚ÇÄ at U'_nhd,
      change V' ‚àà ùìù y‚ÇÄ at V'_nhd,
      have := prod_mem_prod U'_nhd V'_nhd,
      tauto },
    { intros p h',
      simp only [set.mem_preimage, set.prod_mk_mem_set_prod_eq] at h',
      rcases p with ‚ü®‚ü®x, y‚ü©, ‚ü®x', y'‚ü©‚ü©,
      apply h ; tauto } }
end
end dense_inducing

section complete_quotient

universe u
open topological_space classical

/-- The quotient `G ‚ß∏ N` of a complete first countable topological group `G` by a normal subgroup
is itself complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]

Because a topological group is not equipped with a `uniform_space` instance by default, we must
explicitly provide it in order to consider completeness. See `quotient_group.complete_space` for a
version in which `G` is already equipped with a uniform structure. -/
@[to_additive "The quotient `G ‚ß∏ N` of a complete first countable topological additive group
`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by
subspaces are complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]

Because an additive topological group is not equipped with a `uniform_space` instance by default,
we must explicitly provide it in order to consider completeness. See
`quotient_add_group.complete_space` for a version in which `G` is already equipped with a uniform
structure."]
instance quotient_group.complete_space' (G : Type u) [group G] [topological_space G]
  [topological_group G] [first_countable_topology G] (N : subgroup G) [N.normal]
  [@complete_space G (topological_group.to_uniform_space G)] :
  @complete_space (G ‚ß∏ N) (topological_group.to_uniform_space (G ‚ß∏ N)) :=
begin
  /- Since `G ‚ß∏ N` is a topological group it is a uniform space, and since `G` is first countable
  the uniformities of both `G` and `G ‚ß∏ N` are countably generated. Moreover, we may choose a
  sequential antitone neighborhood basis `u` for `ùìù (1 : G)` so that `(u (n + 1)) ^ 2 ‚äÜ u n`, and
  this descends to an antitone neighborhood basis `v` for `ùìù (1 : G ‚ß∏ N)`. Since `ùì§ (G ‚ß∏ N)` is
  countably generated, it suffices to show any Cauchy sequence `x` converges. -/
  letI : uniform_space (G ‚ß∏ N) := topological_group.to_uniform_space (G ‚ß∏ N),
  letI : uniform_space G := topological_group.to_uniform_space G,
  haveI : (ùì§ (G ‚ß∏ N)).is_countably_generated := comap.is_countably_generated _ _,
  obtain ‚ü®u, hu, u_mul‚ü© := topological_group.exists_antitone_basis_nhds_one G,
  obtain ‚ü®hv, v_anti‚ü© := @has_antitone_basis.map _ _ _ _ _ _ (coe : G ‚Üí G ‚ß∏ N) hu,
  rw [‚Üêquotient_group.nhds_eq N 1, quotient_group.coe_one] at hv,
  refine uniform_space.complete_of_cauchy_seq_tendsto (Œª x hx, _),
  /- Given `n : ‚Ñï`, for sufficiently large `a b : ‚Ñï`, given any lift of `x b`, we can find a lift
  of `x a` such that the quotient of the lifts lies in `u n`. -/
  have key‚ÇÄ : ‚àÄ i j : ‚Ñï, ‚àÉ M : ‚Ñï,
    j < M ‚àß ‚àÄ a b : ‚Ñï, M ‚â§ a ‚Üí M ‚â§ b ‚Üí ‚àÄ g : G, x b = g ‚Üí ‚àÉ g' : G, g / g' ‚àà u i ‚àß x a = g',
  { have hùì§GN : (ùì§ (G ‚ß∏ N)).has_basis (Œª _, true) (Œª i, {x | x.snd / x.fst ‚àà coe '' u i}),
    { simpa [uniformity_eq_comap_nhds_one'] using hv.comap _ },
    simp only [hùì§GN.cauchy_seq_iff, ge_iff_le, mem_set_of_eq, forall_true_left, mem_image] at hx,
    intros i j,
    rcases hx i with ‚ü®M, hM‚ü©,
    refine ‚ü®max j M + 1, (le_max_left _ _).trans_lt (lt_add_one _), Œª a b ha hb g hg, _‚ü©,
    obtain ‚ü®y, y_mem, hy‚ü© := hM a (((le_max_right j _).trans (lt_add_one _).le).trans ha) b
      (((le_max_right j _).trans (lt_add_one _).le).trans hb),
    refine ‚ü®y‚Åª¬π * g,
      by simpa only [div_eq_mul_inv, mul_inv_rev, inv_inv, mul_inv_cancel_left] using y_mem, _‚ü©,
    rw [quotient_group.coe_mul, quotient_group.coe_inv, hy, hg, inv_div, div_mul_cancel'], },
  /- Inductively construct a subsequence `œÜ : ‚Ñï ‚Üí ‚Ñï` using `key‚ÇÄ` so that if `a b : ‚Ñï` exceed
  `œÜ (n + 1)`, then we may find lifts whose quotients lie within `u n`. -/
  set œÜ : ‚Ñï ‚Üí ‚Ñï := Œª n, nat.rec_on n (some $ key‚ÇÄ 0 0) (Œª k yk, some $ key‚ÇÄ (k + 1) yk),
  have hœÜ : ‚àÄ n : ‚Ñï, œÜ n < œÜ (n + 1) ‚àß ‚àÄ a b : ‚Ñï, œÜ (n + 1) ‚â§ a ‚Üí œÜ (n + 1) ‚â§ b ‚Üí
    (‚àÄ g : G, x b = g ‚Üí ‚àÉ g' : G, g / g' ‚àà u (n + 1) ‚àß x a = g'),
    from Œª n, some_spec (key‚ÇÄ (n + 1) (œÜ n)),
  /- Inductively construct a sequence `x' n : G` of lifts of `x (œÜ (n + 1))` such that quotients of
  successive terms lie in `x' n / x' (n + 1) ‚àà u (n + 1)`. We actually need the proofs that each
  term is a lift to construct the next term, so we use a Œ£-type. -/
  set x' : Œ† n, psigma (Œª g : G, x (œÜ (n + 1)) = g) :=
    Œª n, nat.rec_on n
      ‚ü®some (quotient_group.mk_surjective (x (œÜ 1))),
       (some_spec (quotient_group.mk_surjective (x (œÜ 1)))).symm‚ü©
      (Œª k hk, ‚ü®some $ (hœÜ k).2 _ _ (hœÜ (k + 1)).1.le le_rfl hk.fst hk.snd,
          (some_spec $ (hœÜ k).2 _ _ (hœÜ (k + 1)).1.le le_rfl hk.fst hk.snd).2‚ü©),
  have hx' : ‚àÄ n : ‚Ñï, (x' n).fst / (x' (n + 1)).fst ‚àà u (n + 1) :=
    Œª n, (some_spec $ (hœÜ n).2 _ _ (hœÜ (n + 1)).1.le le_rfl (x' n).fst (x' n).snd).1,
  /- The sequence `x'` is Cauchy. This is where we exploit the condition on `u`. The key idea
  is to show by decreasing induction that `x' m / x' n ‚àà u m` if `m ‚â§ n`. -/
  have x'_cauchy : cauchy_seq (Œª n, (x' n).fst),
  { have hùì§G : (ùì§ G).has_basis (Œª _, true) (Œª i, {x | x.snd / x.fst ‚àà u i}),
    { simpa [uniformity_eq_comap_nhds_one'] using hu.to_has_basis.comap _ },
    simp only [hùì§G.cauchy_seq_iff', ge_iff_le, mem_set_of_eq, forall_true_left],
    exact Œª m, ‚ü®m, Œª n hmn, nat.decreasing_induction'
      (Œª k hkn hkm hk, u_mul k ‚ü®_, _, hx' k, hk, div_mul_div_cancel' _ _ _‚ü©)
      hmn (by simpa only [div_self'] using mem_of_mem_nhds (hu.mem _))‚ü© },
  /- Since `G` is complete, `x'` converges to some `x‚ÇÄ`, and so the image of this sequence under
  the quotient map converges to `‚Üëx‚ÇÄ`. The image of `x'` is a convergent subsequence of `x`, and
  since `x` is Cauchy, this implies it converges. -/
  rcases cauchy_seq_tendsto_of_complete x'_cauchy with ‚ü®x‚ÇÄ, hx‚ÇÄ‚ü©,
  refine ‚ü®‚Üëx‚ÇÄ, tendsto_nhds_of_cauchy_seq_of_subseq hx
    (strict_mono_nat_of_lt_succ $ Œª n, (hœÜ (n + 1)).1).tendsto_at_top _‚ü©,
  convert ((continuous_coinduced_rng : continuous (coe : G ‚Üí G ‚ß∏ N)).tendsto x‚ÇÄ).comp hx‚ÇÄ,
  exact funext (Œª n, (x' n).snd),
end

/-- The quotient `G ‚ß∏ N` of a complete first countable uniform group `G` by a normal subgroup
is itself complete. In constrast to `quotient_group.complete_space'`, in this version `G` is
already equipped with a uniform structure.
[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]

Even though `G` is equipped with a uniform structure, the quotient `G ‚ß∏ N` does not inherit a
uniform structure, so it is still provided manually via `topological_group.to_uniform_space`.
In the most common use cases, this coincides (definitionally) with the uniform structure on the
quotient obtained via other means.  -/
@[to_additive "The quotient `G ‚ß∏ N` of a complete first countable uniform additive group
`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by
subspaces are complete. In constrast to `quotient_add_group.complete_space'`, in this version
`G` is already equipped with a uniform structure.
[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]

Even though `G` is equipped with a uniform structure, the quotient `G ‚ß∏ N` does not inherit a
uniform structure, so it is still provided manually via `topological_add_group.to_uniform_space`.
In the most common use case ‚îÄ quotients of normed additive commutative groups by subgroups ‚îÄ
significant care was taken so that the uniform structure inherent in that setting coincides
(definitionally) with the uniform structure provided here."]
instance quotient_group.complete_space (G : Type u) [group G] [us : uniform_space G]
  [uniform_group G] [first_countable_topology G] (N : subgroup G) [N.normal]
  [hG : complete_space G] : @complete_space (G ‚ß∏ N) (topological_group.to_uniform_space (G ‚ß∏ N)) :=
by { unfreezingI { rw ‚Üê@uniform_group.to_uniform_space_eq _ us _ _ at hG }, apply_instance }


end complete_quotient
