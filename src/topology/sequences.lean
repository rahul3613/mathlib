/-
Copyright (c) 2018 Jan-David Salchow. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jan-David Salchow, Patrick Massot, Yury Kudryashov
-/
import topology.subset_properties
import topology.metric_space.basic

/-!
# Sequences in topological spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define sequences in topological spaces and show how they are related to
filters and the topology.

## Main definitions

### Set operation
* `seq_closure s`: sequential closure of a set, the set of limits of sequences of points of `s`;

### Predicates

* `is_seq_closed s`: predicate saying that a set is sequentially closed, i.e., `seq_closure s ‚äÜ s`;
* `seq_continuous f`: predicate saying that a function is sequentially continuous, i.e.,
  for any sequence `u : ‚Ñï ‚Üí X` that converges to a point `x`, the sequence `f ‚àò u` converges to
  `f x`;
* `is_seq_compact s`: predicate saying that a set is sequentially compact, i.e., every sequence
  taking values in `s` has a converging subsequence.

### Type classes

* `frechet_urysohn_space X`: a typeclass saying that a topological space is a *Fr√©chet-Urysohn
  space*, i.e., the sequential closure of any set is equal to its closure.
* `sequential_space X`: a typeclass saying that a topological space is a *sequential space*, i.e.,
  any sequentially closed set in this space is closed. This condition is weaker than being a
  Fr√©chet-Urysohn space.
* `seq_compact_space X`: a typeclass saying that a topological space is sequentially compact, i.e.,
  every sequence in `X` has a converging subsequence.

## Main results

* `seq_closure_subset_closure`: closure of a set includes its sequential closure;
* `is_closed.is_seq_closed`: a closed set is sequentially closed;
* `is_seq_closed.seq_closure_eq`: sequential closure of a sequentially closed set `s` is equal
  to `s`;
* `seq_closure_eq_closure`: in a Fr√©chet-Urysohn space, the sequential closure of a set is equal to
  its closure;
* `tendsto_nhds_iff_seq_tendsto`, `frechet_urysohn_space.of_seq_tendsto_imp_tendsto`: a topological
  space is a Fr√©chet-Urysohn space if and only if sequential convergence implies convergence;
* `topological_space.first_countable_topology.frechet_urysohn_space`: every topological space with
  first countable topology is a Fr√©chet-Urysohn space;
* `frechet_urysohn_space.to_sequential_space`: every Fr√©chet-Urysohn space is a sequential space;
* `is_seq_compact.is_compact`: a sequentially compact set in a uniform space with countably
  generated uniformity is compact.

## Tags

sequentially closed, sequentially compact, sequential space
-/

open set function filter topological_space
open_locale topology filter

variables {X Y : Type*}

/-! ### Sequential closures, sequential continuity, and sequential spaces. -/
section topological_space
variables [topological_space X] [topological_space Y]

/-- The sequential closure of a set `s : set X` in a topological space `X` is the set of all `a : X`
which arise as limit of sequences in `s`. Note that the sequential closure of a set is not
guaranteed to be sequentially closed. -/
def seq_closure (s : set X) : set X :=
{a | ‚àÉ x : ‚Ñï ‚Üí X, (‚àÄ n : ‚Ñï, x n ‚àà s) ‚àß tendsto x at_top (ùìù a)}

lemma subset_seq_closure {s : set X} : s ‚äÜ seq_closure s :=
Œª p hp, ‚ü®const ‚Ñï p, Œª _, hp, tendsto_const_nhds‚ü©

/-- The sequential closure of a set is contained in the closure of that set.
The converse is not true. -/
lemma seq_closure_subset_closure {s : set X} : seq_closure s ‚äÜ closure s :=
Œª p ‚ü®x, xM, xp‚ü©, mem_closure_of_tendsto xp (univ_mem' xM)

/-- A set `s` is sequentially closed if for any converging sequence `x n` of elements of `s`, the
limit belongs to `s` as well. Note that the sequential closure of a set is not guaranteed to be
sequentially closed. -/
def is_seq_closed (s : set X) : Prop :=
‚àÄ ‚¶Éx : ‚Ñï ‚Üí X‚¶Ñ ‚¶Ép : X‚¶Ñ, (‚àÄ n, x n ‚àà s) ‚Üí tendsto x at_top (ùìù p) ‚Üí p ‚àà s

/-- The sequential closure of a sequentially closed set is the set itself. -/
lemma is_seq_closed.seq_closure_eq {s : set X} (hs : is_seq_closed s) :
  seq_closure s = s :=
subset.antisymm (Œª p ‚ü®x, hx, hp‚ü©, hs hx hp) subset_seq_closure

/-- If a set is equal to its sequential closure, then it is sequentially closed. -/
lemma is_seq_closed_of_seq_closure_eq {s : set X} (hs : seq_closure s = s) :
  is_seq_closed s :=
Œª x p hxs hxp, hs ‚ñ∏ ‚ü®x, hxs, hxp‚ü©

/-- A set is sequentially closed iff it is equal to its sequential closure. -/
lemma is_seq_closed_iff {s : set X} :
  is_seq_closed s ‚Üî seq_closure s = s :=
‚ü®is_seq_closed.seq_closure_eq, is_seq_closed_of_seq_closure_eq‚ü©

/-- A set is sequentially closed if it is closed. -/
protected lemma is_closed.is_seq_closed {s : set X} (hc : is_closed s) : is_seq_closed s :=
Œª u x hu hx, hc.mem_of_tendsto hx (eventually_of_forall hu)

/-- A topological space is called a *Fr√©chet-Urysohn space*, if the sequential closure of any set
is equal to its closure. Since one of the inclusions is trivial, we require only the non-trivial one
in the definition. -/
class frechet_urysohn_space (X : Type*) [topological_space X] : Prop :=
(closure_subset_seq_closure : ‚àÄ s : set X, closure s ‚äÜ seq_closure s)

lemma seq_closure_eq_closure [frechet_urysohn_space X] (s : set X) :
  seq_closure s = closure s :=
seq_closure_subset_closure.antisymm $ frechet_urysohn_space.closure_subset_seq_closure s

/-- In a Fr√©chet-Urysohn space, a point belongs to the closure of a set iff it is a limit
of a sequence taking values in this set. -/
lemma mem_closure_iff_seq_limit [frechet_urysohn_space X] {s : set X} {a : X} :
  a ‚àà closure s ‚Üî ‚àÉ x : ‚Ñï ‚Üí X, (‚àÄ n : ‚Ñï, x n ‚àà s) ‚àß tendsto x at_top (ùìù a) :=
by { rw [‚Üê seq_closure_eq_closure], refl }

/-- If the domain of a function `f : Œ± ‚Üí Œ≤` is a Fr√©chet-Urysohn space, then convergence
is equivalent to sequential convergence. See also `filter.tendsto_iff_seq_tendsto` for a version
that works for any pair of filters assuming that the filter in the domain is countably generated.

This property is equivalent to the definition of `frechet_urysohn_space`, see
`frechet_urysohn_space.of_seq_tendsto_imp_tendsto`. -/
lemma tendsto_nhds_iff_seq_tendsto [frechet_urysohn_space X] {f : X ‚Üí Y} {a : X} {b : Y} :
  tendsto f (ùìù a) (ùìù b) ‚Üî ‚àÄ u : ‚Ñï ‚Üí X, tendsto u at_top (ùìù a) ‚Üí tendsto (f ‚àò u) at_top (ùìù b) :=
begin
  refine ‚ü®Œª hf u hu, hf.comp hu,
    Œª h, ((nhds_basis_closeds _).tendsto_iff (nhds_basis_closeds _)).2 _‚ü©,
  rintro s ‚ü®hbs, hsc‚ü©,
  refine ‚ü®closure (f ‚Åª¬π' s), ‚ü®mt _ hbs, is_closed_closure‚ü©, Œª x, mt $ Œª hx, subset_closure hx‚ü©,
  rw [‚Üê seq_closure_eq_closure],
  rintro ‚ü®u, hus, hu‚ü©,
  exact hsc.mem_of_tendsto (h u hu) (eventually_of_forall hus)
end

/-- An alternative construction for `frechet_urysohn_space`: if sequential convergence implies
convergence, then the space is a Fr√©chet-Urysohn space. -/
lemma frechet_urysohn_space.of_seq_tendsto_imp_tendsto
  (h : ‚àÄ (f : X ‚Üí Prop) (a : X),
    (‚àÄ u : ‚Ñï ‚Üí X, tendsto u at_top (ùìù a) ‚Üí tendsto (f ‚àò u) at_top (ùìù (f a))) ‚Üí continuous_at f a) :
  frechet_urysohn_space X :=
begin
  refine ‚ü®Œª s x hcx, _‚ü©,
  specialize h (‚àâ s) x,
  by_cases hx : x ‚àà s, { exact subset_seq_closure hx },
  simp_rw [(‚àò), continuous_at, hx, not_false_iff, nhds_true, tendsto_pure, eq_true_iff,
    ‚Üê mem_compl_iff, eventually_mem_set, ‚Üê mem_interior_iff_mem_nhds, interior_compl] at h,
  rw [mem_compl_iff, imp_not_comm] at h,
  simp only [not_forall, not_eventually, mem_compl_iff, not_not] at h,
  rcases h hcx with ‚ü®u, hux, hus‚ü©,
  rcases extraction_of_frequently_at_top hus with ‚ü®œÜ, œÜ_mono, hœÜ‚ü©,
  exact ‚ü®u ‚àò œÜ, hœÜ, hux.comp œÜ_mono.tendsto_at_top‚ü©
end

/-- Every first-countable space is a Fr√©chet-Urysohn space. -/
@[priority 100] -- see Note [lower instance priority]
instance topological_space.first_countable_topology.frechet_urysohn_space
  [first_countable_topology X] : frechet_urysohn_space X :=
frechet_urysohn_space.of_seq_tendsto_imp_tendsto $ Œª f a, tendsto_iff_seq_tendsto.2

/-- A topological space is said to be a *sequential space* if any sequentially closed set in this
space is closed. This condition is weaker than being a Fr√©chet-Urysohn space. -/
class sequential_space (X : Type*) [topological_space X] : Prop :=
(is_closed_of_seq : ‚àÄ s : set X, is_seq_closed s ‚Üí is_closed s)

/-- Every Fr√©chet-Urysohn space is a sequential space. -/
@[priority 100] -- see Note [lower instance priority]
instance frechet_urysohn_space.to_sequential_space [frechet_urysohn_space X] :
  sequential_space X :=
‚ü®Œª s hs, by rw [‚Üê closure_eq_iff_is_closed, ‚Üê seq_closure_eq_closure, hs.seq_closure_eq]‚ü©

/-- In a sequential space, a sequentially closed set is closed. -/
protected lemma is_seq_closed.is_closed [sequential_space X] {s : set X} (hs : is_seq_closed s) :
  is_closed s :=
sequential_space.is_closed_of_seq s hs

/-- In a sequential space, a set is closed iff it's sequentially closed. -/
lemma is_seq_closed_iff_is_closed [sequential_space X] {M : set X} :
  is_seq_closed M ‚Üî is_closed M :=
‚ü®is_seq_closed.is_closed, is_closed.is_seq_closed‚ü©

/-- A function between topological spaces is sequentially continuous if it commutes with limit of
 convergent sequences. -/
def seq_continuous (f : X ‚Üí Y) : Prop :=
‚àÄ ‚¶Éx : ‚Ñï ‚Üí X‚¶Ñ ‚¶Ép : X‚¶Ñ, tendsto x at_top (ùìù p) ‚Üí tendsto (f ‚àò x) at_top (ùìù (f p))

/-- The preimage of a sequentially closed set under a sequentially continuous map is sequentially
closed. -/
lemma is_seq_closed.preimage {f : X ‚Üí Y} {s : set Y} (hs : is_seq_closed s)
  (hf : seq_continuous f) :
  is_seq_closed (f ‚Åª¬π' s) :=
Œª x p hx hp, hs hx (hf hp)

/- A continuous function is sequentially continuous. -/
protected lemma continuous.seq_continuous {f : X ‚Üí Y} (hf : continuous f) :
  seq_continuous f :=
Œª x p hx, (hf.tendsto p).comp hx

/-- A sequentially continuous function defined on a sequential space is continuous. -/
protected lemma seq_continuous.continuous [sequential_space X] {f : X ‚Üí Y} (hf : seq_continuous f) :
  continuous f :=
continuous_iff_is_closed.mpr $ Œª s hs, (hs.is_seq_closed.preimage hf).is_closed

/-- If the domain of a function is a sequential space, then continuity of this function is
equivalent to its sequential continuity. -/
lemma continuous_iff_seq_continuous [sequential_space X] {f : X ‚Üí Y} :
  continuous f ‚Üî seq_continuous f :=
‚ü®continuous.seq_continuous, seq_continuous.continuous‚ü©

lemma quotient_map.sequential_space [sequential_space X] {f : X ‚Üí Y} (hf : quotient_map f) :
  sequential_space Y :=
‚ü®Œª s hs, hf.is_closed_preimage.mp $ (hs.preimage $ hf.continuous.seq_continuous).is_closed‚ü©

/-- The quotient of a sequential space is a sequential space. -/
instance [sequential_space X] {s : setoid X} : sequential_space (quotient s) :=
quotient_map_quot_mk.sequential_space

end topological_space

section seq_compact
open topological_space topological_space.first_countable_topology
variables [topological_space X]

/-- A set `s` is sequentially compact if every sequence taking values in `s` has a
converging subsequence. -/
def is_seq_compact (s : set X) :=
‚àÄ ‚¶Éx : ‚Ñï ‚Üí X‚¶Ñ, (‚àÄ n, x n ‚àà s) ‚Üí ‚àÉ (a ‚àà s) (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a)

/-- A space `X` is sequentially compact if every sequence in `X` has a
converging subsequence. -/
@[mk_iff] class seq_compact_space (X : Type*) [topological_space X] : Prop :=
(seq_compact_univ : is_seq_compact (univ : set X))

export seq_compact_space (seq_compact_univ)

lemma is_seq_compact.subseq_of_frequently_in {s : set X} (hs : is_seq_compact s) {x : ‚Ñï ‚Üí X}
  (hx : ‚àÉ·∂† n in at_top, x n ‚àà s) :
  ‚àÉ (a ‚àà s) (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
let ‚ü®œà, hœà, huœà‚ü© := extraction_of_frequently_at_top hx, ‚ü®a, a_in, œÜ, hœÜ, h‚ü© := hs huœà in
‚ü®a, a_in, œà ‚àò œÜ, hœà.comp hœÜ, h‚ü©

lemma seq_compact_space.tendsto_subseq [seq_compact_space X] (x : ‚Ñï ‚Üí X) :
  ‚àÉ a (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
let ‚ü®a, _, œÜ, mono, h‚ü© := seq_compact_univ (Œª n, mem_univ (x n)) in ‚ü®a, œÜ, mono, h‚ü©

section first_countable_topology
variables [first_countable_topology X]
open topological_space.first_countable_topology

protected lemma is_compact.is_seq_compact {s : set X} (hs : is_compact s) : is_seq_compact s :=
Œª x x_in, let ‚ü®a, a_in, ha‚ü© := hs (tendsto_principal.mpr (eventually_of_forall x_in))
in ‚ü®a, a_in, tendsto_subseq ha‚ü©

lemma is_compact.tendsto_subseq' {s : set X} {x : ‚Ñï ‚Üí X} (hs : is_compact s)
  (hx : ‚àÉ·∂† n in at_top, x n ‚àà s) :
  ‚àÉ (a ‚àà s) (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
hs.is_seq_compact.subseq_of_frequently_in hx

lemma is_compact.tendsto_subseq {s : set X} {x : ‚Ñï ‚Üí X} (hs : is_compact s) (hx : ‚àÄ n, x n ‚àà s) :
  ‚àÉ (a ‚àà s) (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
hs.is_seq_compact hx

@[priority 100] -- see Note [lower instance priority]
instance first_countable_topology.seq_compact_of_compact [compact_space X] : seq_compact_space X :=
‚ü®is_compact_univ.is_seq_compact‚ü©

lemma compact_space.tendsto_subseq [compact_space X] (x : ‚Ñï ‚Üí X) :
  ‚àÉ a (œÜ : ‚Ñï ‚Üí ‚Ñï), strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
seq_compact_space.tendsto_subseq x

end first_countable_topology
end seq_compact

section uniform_space_seq_compact

open_locale uniformity
open uniform_space prod

variables [uniform_space X] {s : set X}

lemma is_seq_compact.exists_tendsto_of_frequently_mem (hs : is_seq_compact s) {u : ‚Ñï ‚Üí X}
  (hu : ‚àÉ·∂† n in at_top, u n ‚àà s) (huc : cauchy_seq u) :
  ‚àÉ x ‚àà s, tendsto u at_top (ùìù x) :=
let ‚ü®x, hxs, œÜ, œÜ_mono, hx‚ü© := hs.subseq_of_frequently_in hu
in ‚ü®x, hxs, tendsto_nhds_of_cauchy_seq_of_subseq huc œÜ_mono.tendsto_at_top hx‚ü©

lemma is_seq_compact.exists_tendsto (hs : is_seq_compact s) {u : ‚Ñï ‚Üí X} (hu : ‚àÄ n, u n ‚àà s)
  (huc : cauchy_seq u) : ‚àÉ x ‚àà s, tendsto u at_top (ùìù x) :=
hs.exists_tendsto_of_frequently_mem (frequently_of_forall hu) huc

/-- A sequentially compact set in a uniform space is totally bounded. -/
protected lemma is_seq_compact.totally_bounded (h : is_seq_compact s) : totally_bounded s :=
begin
  intros V V_in,
  unfold is_seq_compact at h,
  contrapose! h,
  obtain ‚ü®u, u_in, hu‚ü© : ‚àÉ u : ‚Ñï ‚Üí X, (‚àÄ n, u n ‚àà s) ‚àß ‚àÄ n m, m < n ‚Üí u m ‚àâ ball (u n) V,
  { simp only [not_subset, mem_Union‚ÇÇ, not_exists, exists_prop] at h,
    simpa only [forall_and_distrib, ball_image_iff, not_and] using seq_of_forall_finite_exists h },
  refine ‚ü®u, u_in, Œª x x_in œÜ hœÜ huœÜ, _‚ü©,
  obtain ‚ü®N, hN‚ü© : ‚àÉ N, ‚àÄ p q, p ‚â• N ‚Üí q ‚â• N ‚Üí (u (œÜ p), u (œÜ q)) ‚àà V,
    from huœÜ.cauchy_seq.mem_entourage V_in,
  exact hu (œÜ $ N + 1) (œÜ N) (hœÜ $ lt_add_one N) (hN (N + 1) N N.le_succ le_rfl)
end

variables [is_countably_generated (ùì§ X)]

/-- A sequentially compact set in a uniform set with countably generated uniformity filter
is complete. -/
protected lemma is_seq_compact.is_complete (hs : is_seq_compact s) : is_complete s :=
begin
  intros l hl hls,
  haveI := hl.1,
  rcases exists_antitone_basis (ùì§ X) with ‚ü®V, hV‚ü©,
  choose W hW hWV using Œª n, comp_mem_uniformity_sets (hV.mem n),
  have hWV' : ‚àÄ n, W n ‚äÜ V n, from Œª n ‚ü®x, y‚ü© hx, @hWV n (x, y) ‚ü®x, refl_mem_uniformity $ hW _, hx‚ü©,
  obtain ‚ü®t, ht_anti, htl, htW, hts‚ü© : ‚àÉ t : ‚Ñï ‚Üí set X, antitone t ‚àß (‚àÄ n, t n ‚àà l) ‚àß
    (‚àÄ n, t n √óÀ¢ t n ‚äÜ W n) ‚àß (‚àÄ n, t n ‚äÜ s),
  { have : ‚àÄ n, ‚àÉ t ‚àà l, t √óÀ¢ t ‚äÜ W n ‚àß t ‚äÜ s,
    { rw [le_principal_iff] at hls,
      have : ‚àÄ n, W n ‚à© s √óÀ¢ s ‚àà l √ó·∂† l := Œª n, inter_mem (hl.2 (hW n)) (prod_mem_prod hls hls),
      simpa only [l.basis_sets.prod_self.mem_iff, true_implies_iff, subset_inter_iff,
        prod_self_subset_prod_self, and.assoc] using this },
    choose t htl htW hts,
    have : ‚àÄ n, (‚ãÇ k ‚â§ n, t k) ‚äÜ t n, from Œª n, Inter‚ÇÇ_subset _ le_rfl,
    exact ‚ü®Œª n, ‚ãÇ k ‚â§ n, t k, Œª m n h, bInter_subset_bInter_left (Œª k (hk : k ‚â§ m), hk.trans h),
      Œª n, (bInter_mem (finite_le_nat n)).2 (Œª k hk, htl k),
      Œª n, (prod_mono (this n) (this n)).trans (htW n), Œª n, (this n).trans (hts n)‚ü© },
  choose u hu using Œª n, filter.nonempty_of_mem (htl n),
  have huc : cauchy_seq u := hV.to_has_basis.cauchy_seq_iff.2
    (Œª N hN, ‚ü®N, Œª m hm n hn, hWV' _ $ @htW N (_, _) ‚ü®ht_anti hm (hu _), (ht_anti hn (hu _))‚ü©‚ü©),
  rcases hs.exists_tendsto (Œª n, hts n (hu n)) huc with ‚ü®x, hxs, hx‚ü©,
  refine ‚ü®x, hxs, (nhds_basis_uniformity' hV.to_has_basis).ge_iff.2 $ Œª N hN, _‚ü©,
  obtain ‚ü®n, hNn, hn‚ü© : ‚àÉ n, N ‚â§ n ‚àß u n ‚àà ball x (W N),
    from ((eventually_ge_at_top N).and (hx $ ball_mem_nhds x (hW N))).exists,
  refine mem_of_superset (htl n) (Œª y hy, hWV N ‚ü®u n, _, htW N ‚ü®_, _‚ü©‚ü©),
  exacts [hn, ht_anti hNn (hu n), ht_anti hNn hy]
end

/-- If `ùì§ Œ≤` is countably generated, then any sequentially compact set is compact. -/
protected lemma is_seq_compact.is_compact (hs : is_seq_compact s) : is_compact s :=
is_compact_iff_totally_bounded_is_complete.2 ‚ü®hs.totally_bounded, hs.is_complete‚ü©

/-- A version of Bolzano-Weistrass: in a uniform space with countably generated uniformity filter
(e.g., in a metric space), a set is compact if and only if it is sequentially compact. -/
protected lemma uniform_space.is_compact_iff_is_seq_compact : is_compact s ‚Üî is_seq_compact s :=
‚ü®Œª H, H.is_seq_compact, Œª H, H.is_compact‚ü©

lemma uniform_space.compact_space_iff_seq_compact_space : compact_space X ‚Üî seq_compact_space X :=
by simp only [‚Üê is_compact_univ_iff, seq_compact_space_iff,
  uniform_space.is_compact_iff_is_seq_compact]

end uniform_space_seq_compact

section metric_seq_compact

variables [pseudo_metric_space X]
open metric

lemma seq_compact.lebesgue_number_lemma_of_metric {Œπ : Sort*} {c : Œπ ‚Üí set X}
  {s : set X} (hs : is_seq_compact s) (hc‚ÇÅ : ‚àÄ i, is_open (c i)) (hc‚ÇÇ : s ‚äÜ ‚ãÉ i, c i) :
  ‚àÉ Œ¥ > 0, ‚àÄ a ‚àà s, ‚àÉ i, ball a Œ¥ ‚äÜ c i :=
lebesgue_number_lemma_of_metric hs.is_compact hc‚ÇÅ hc‚ÇÇ

variables [proper_space X] {s : set X}

/-- A version of **Bolzano-Weistrass**: in a proper metric space (eg. $‚Ñù^n$),
every bounded sequence has a converging subsequence. This version assumes only
that the sequence is frequently in some bounded set. -/
lemma tendsto_subseq_of_frequently_bounded (hs : bounded s)
  {x : ‚Ñï ‚Üí X} (hx : ‚àÉ·∂† n in at_top, x n ‚àà s) :
  ‚àÉ a ‚àà closure s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
have hcs : is_seq_compact (closure s), from hs.is_compact_closure.is_seq_compact,
have hu' : ‚àÉ·∂† n in at_top, x n ‚àà closure s, from hx.mono (Œª n hn, subset_closure hn),
hcs.subseq_of_frequently_in hu'

/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $‚Ñù^n$),
every bounded sequence has a converging subsequence. -/
lemma tendsto_subseq_of_bounded (hs : bounded s) {x : ‚Ñï ‚Üí X} (hx : ‚àÄ n, x n ‚àà s) :
  ‚àÉ a ‚àà closure s, ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß tendsto (x ‚àò œÜ) at_top (ùìù a) :=
tendsto_subseq_of_frequently_bounded hs $ frequently_of_forall hx

end metric_seq_compact
