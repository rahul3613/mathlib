/-
Copyright (c) 2020 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import topology.metric_space.lipschitz
import topology.uniform_space.complete_separated

/-!
# Antilipschitz functions

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We say that a map `f : Œ± ‚Üí Œ≤` between two (extended) metric spaces is
`antilipschitz_with K`, `K ‚â• 0`, if for all `x, y` we have `edist x y ‚â§ K * edist (f x) (f y)`.
For a metric space, the latter inequality is equivalent to `dist x y ‚â§ K * dist (f x) (f y)`.

## Implementation notes

The parameter `K` has type `‚Ñù‚â•0`. This way we avoid conjuction in the definition and have
coercions both to `‚Ñù` and `‚Ñù‚â•0‚àû`. We do not require `0 < K` in the definition, mostly because
we do not have a `posreal` type.
-/

variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*}

open_locale nnreal ennreal uniformity
open set filter bornology

/-- We say that `f : Œ± ‚Üí Œ≤` is `antilipschitz_with K` if for any two points `x`, `y` we have
`edist x y ‚â§ K * edist (f x) (f y)`. -/
def antilipschitz_with [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] (K : ‚Ñù‚â•0) (f : Œ± ‚Üí Œ≤) :=
‚àÄ x y, edist x y ‚â§ K * edist (f x) (f y)

lemma antilipschitz_with.edist_lt_top [pseudo_emetric_space Œ±] [pseudo_metric_space Œ≤] {K : ‚Ñù‚â•0}
  {f : Œ± ‚Üí Œ≤} (h : antilipschitz_with K f) (x y : Œ±) : edist x y < ‚ä§ :=
(h x y).trans_lt $ ennreal.mul_lt_top ennreal.coe_ne_top (edist_ne_top _ _)

lemma antilipschitz_with.edist_ne_top [pseudo_emetric_space Œ±] [pseudo_metric_space Œ≤] {K : ‚Ñù‚â•0}
  {f : Œ± ‚Üí Œ≤} (h : antilipschitz_with K f) (x y : Œ±) : edist x y ‚â† ‚ä§ :=
(h.edist_lt_top x y).ne

section metric

variables [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] {K : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤}

lemma antilipschitz_with_iff_le_mul_nndist :
  antilipschitz_with K f ‚Üî ‚àÄ x y, nndist x y ‚â§ K * nndist (f x) (f y) :=
by { simp only [antilipschitz_with, edist_nndist], norm_cast }

alias antilipschitz_with_iff_le_mul_nndist ‚Üî antilipschitz_with.le_mul_nndist
  antilipschitz_with.of_le_mul_nndist

lemma antilipschitz_with_iff_le_mul_dist :
  antilipschitz_with K f ‚Üî ‚àÄ x y, dist x y ‚â§ K * dist (f x) (f y) :=
by { simp only [antilipschitz_with_iff_le_mul_nndist, dist_nndist], norm_cast }

alias antilipschitz_with_iff_le_mul_dist ‚Üî antilipschitz_with.le_mul_dist
  antilipschitz_with.of_le_mul_dist

namespace antilipschitz_with

lemma mul_le_nndist (hf : antilipschitz_with K f) (x y : Œ±) :
  K‚Åª¬π * nndist x y ‚â§ nndist (f x) (f y) :=
by simpa only [div_eq_inv_mul] using nnreal.div_le_of_le_mul' (hf.le_mul_nndist x y)

lemma mul_le_dist (hf : antilipschitz_with K f) (x y : Œ±) :
  (K‚Åª¬π * dist x y : ‚Ñù) ‚â§ dist (f x) (f y) :=
by exact_mod_cast hf.mul_le_nndist x y

end antilipschitz_with

end metric

namespace antilipschitz_with

variables [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] [pseudo_emetric_space Œ≥]
variables {K : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤}

open emetric

/-- Extract the constant from `hf : antilipschitz_with K f`. This is useful, e.g.,
if `K` is given by a long formula, and we want to reuse this value. -/
@[nolint unused_arguments] -- uses neither `f` nor `hf`
protected def K (hf : antilipschitz_with K f) : ‚Ñù‚â•0 := K

protected lemma injective {Œ± : Type*} {Œ≤ : Type*} [emetric_space Œ±] [pseudo_emetric_space Œ≤]
  {K : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤} (hf : antilipschitz_with K f) : function.injective f :=
Œª x y h, by simpa only [h, edist_self, mul_zero, edist_le_zero] using hf x y

lemma mul_le_edist (hf : antilipschitz_with K f) (x y : Œ±) :
  (K‚Åª¬π * edist x y : ‚Ñù‚â•0‚àû) ‚â§ edist (f x) (f y) :=
begin
  rw [mul_comm, ‚Üê div_eq_mul_inv],
  exact ennreal.div_le_of_le_mul' (hf x y)
end

lemma ediam_preimage_le (hf : antilipschitz_with K f) (s : set Œ≤) : diam (f ‚Åª¬π' s) ‚â§ K * diam s :=
diam_le $ Œª x hx y hy, (hf x y).trans $ mul_le_mul_left' (edist_le_diam_of_mem hx hy) K

lemma le_mul_ediam_image (hf : antilipschitz_with K f) (s : set Œ±) : diam s ‚â§ K * diam (f '' s) :=
(diam_mono (subset_preimage_image _ _)).trans (hf.ediam_preimage_le (f '' s))

protected lemma id : antilipschitz_with 1 (id : Œ± ‚Üí Œ±) :=
Œª x y, by simp only [ennreal.coe_one, one_mul, id, le_refl]

lemma comp {Kg : ‚Ñù‚â•0} {g : Œ≤ ‚Üí Œ≥} (hg : antilipschitz_with Kg g)
  {Kf : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤} (hf : antilipschitz_with Kf f) :
  antilipschitz_with (Kf * Kg) (g ‚àò f) :=
Œª x y,
calc edist x y ‚â§ Kf * edist (f x) (f y) : hf x y
... ‚â§ Kf * (Kg * edist (g (f x)) (g (f y))) : ennreal.mul_left_mono (hg _ _)
... = _ : by rw [ennreal.coe_mul, mul_assoc]

lemma restrict (hf : antilipschitz_with K f) (s : set Œ±) :
  antilipschitz_with K (s.restrict f) :=
Œª x y, hf x y

lemma cod_restrict (hf : antilipschitz_with K f) {s : set Œ≤} (hs : ‚àÄ x, f x ‚àà s) :
  antilipschitz_with K (s.cod_restrict f hs) :=
Œª x y, hf x y

lemma to_right_inv_on' {s : set Œ±} (hf : antilipschitz_with K (s.restrict f))
  {g : Œ≤ ‚Üí Œ±} {t : set Œ≤} (g_maps : maps_to g t s) (g_inv : right_inv_on g f t) :
  lipschitz_with K (t.restrict g) :=
Œª x y, by simpa only [restrict_apply, g_inv x.mem, g_inv y.mem, subtype.edist_eq, subtype.coe_mk]
  using hf ‚ü®g x, g_maps x.mem‚ü© ‚ü®g y, g_maps y.mem‚ü©

lemma to_right_inv_on (hf : antilipschitz_with K f) {g : Œ≤ ‚Üí Œ±} {t : set Œ≤}
  (h : right_inv_on g f t) :
  lipschitz_with K (t.restrict g) :=
(hf.restrict univ).to_right_inv_on' (maps_to_univ g t) h

lemma to_right_inverse (hf : antilipschitz_with K f) {g : Œ≤ ‚Üí Œ±} (hg : function.right_inverse g f) :
  lipschitz_with K g :=
begin
  intros x y,
  have := hf (g x) (g y),
  rwa [hg x, hg y] at this
end

lemma comap_uniformity_le (hf : antilipschitz_with K f) :
  (ùì§ Œ≤).comap (prod.map f f) ‚â§ ùì§ Œ± :=
begin
  refine ((uniformity_basis_edist.comap _).le_basis_iff uniformity_basis_edist).2 (Œª Œµ h‚ÇÄ, _),
  refine ‚ü®K‚Åª¬π * Œµ, ennreal.mul_pos (ennreal.inv_ne_zero.2 ennreal.coe_ne_top) h‚ÇÄ.ne', _‚ü©,
  refine Œª x hx, (hf x.1 x.2).trans_lt _,
  rw [mul_comm, ‚Üê div_eq_mul_inv] at hx,
  rw mul_comm,
  exact ennreal.mul_lt_of_lt_div hx
end

protected lemma uniform_inducing (hf : antilipschitz_with K f) (hfc : uniform_continuous f) :
  uniform_inducing f :=
‚ü®le_antisymm hf.comap_uniformity_le hfc.le_comap‚ü©

protected lemma uniform_embedding {Œ± : Type*} {Œ≤ : Type*} [emetric_space Œ±] [pseudo_emetric_space Œ≤]
  {K : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤} (hf : antilipschitz_with K f) (hfc : uniform_continuous f) :
  uniform_embedding f :=
‚ü®hf.uniform_inducing hfc, hf.injective‚ü©

lemma is_complete_range [complete_space Œ±] (hf : antilipschitz_with K f)
  (hfc : uniform_continuous f) : is_complete (range f) :=
(hf.uniform_inducing hfc).is_complete_range

lemma is_closed_range {Œ± Œ≤ : Type*} [pseudo_emetric_space Œ±] [emetric_space Œ≤] [complete_space Œ±]
  {f : Œ± ‚Üí Œ≤} {K : ‚Ñù‚â•0} (hf : antilipschitz_with K f) (hfc : uniform_continuous f) :
  is_closed (range f) :=
(hf.is_complete_range hfc).is_closed

lemma closed_embedding {Œ± : Type*} {Œ≤ : Type*} [emetric_space Œ±] [emetric_space Œ≤] {K : ‚Ñù‚â•0}
  {f : Œ± ‚Üí Œ≤} [complete_space Œ±] (hf : antilipschitz_with K f) (hfc : uniform_continuous f) :
  closed_embedding f :=
{ closed_range := hf.is_closed_range hfc,
  .. (hf.uniform_embedding hfc).embedding }

lemma subtype_coe (s : set Œ±) : antilipschitz_with 1 (coe : s ‚Üí Œ±) :=
antilipschitz_with.id.restrict s

lemma of_subsingleton [subsingleton Œ±] {K : ‚Ñù‚â•0} : antilipschitz_with K f :=
Œª x y, by simp only [subsingleton.elim x y, edist_self, zero_le]

/-- If `f : Œ± ‚Üí Œ≤` is `0`-antilipschitz, then `Œ±` is a `subsingleton`. -/
protected lemma subsingleton {Œ± Œ≤} [emetric_space Œ±] [pseudo_emetric_space Œ≤] {f : Œ± ‚Üí Œ≤}
  (h : antilipschitz_with 0 f) : subsingleton Œ± :=
‚ü®Œª x y, edist_le_zero.1 $ (h x y).trans_eq $ zero_mul _‚ü©

end antilipschitz_with

namespace antilipschitz_with

open metric

variables [pseudo_metric_space Œ±] [pseudo_metric_space Œ≤] [pseudo_metric_space Œ≥]
variables {K : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤}

lemma bounded_preimage (hf : antilipschitz_with K f)
  {s : set Œ≤} (hs : bounded s) :
  bounded (f ‚Åª¬π' s) :=
exists.intro (K * diam s) $ Œª x hx y hy,
calc dist x y ‚â§ K * dist (f x) (f y) : hf.le_mul_dist x y
... ‚â§ K * diam s : mul_le_mul_of_nonneg_left (dist_le_diam_of_mem hs hx hy) K.2

lemma tendsto_cobounded (hf : antilipschitz_with K f) : tendsto f (cobounded Œ±) (cobounded Œ≤) :=
compl_surjective.forall.2 $ Œª s (hs : is_bounded s), metric.is_bounded_iff.2 $
  hf.bounded_preimage $ metric.is_bounded_iff.1 hs

/-- The image of a proper space under an expanding onto map is proper. -/
protected lemma proper_space {Œ± : Type*} [metric_space Œ±] {K : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤} [proper_space Œ±]
  (hK : antilipschitz_with K f) (f_cont : continuous f) (hf : function.surjective f) :
  proper_space Œ≤ :=
begin
  apply proper_space_of_compact_closed_ball_of_le 0 (Œªx‚ÇÄ r hr, _),
  let K := f ‚Åª¬π' (closed_ball x‚ÇÄ r),
  have A : is_closed K := is_closed_ball.preimage f_cont,
  have B : bounded K := hK.bounded_preimage bounded_closed_ball,
  have : is_compact K := is_compact_iff_is_closed_bounded.2 ‚ü®A, B‚ü©,
  convert this.image f_cont,
  exact (hf.image_preimage _).symm
end

lemma bounded_of_image2_left (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) {K‚ÇÅ : ‚Ñù‚â•0}
  (hf : ‚àÄ b, antilipschitz_with K‚ÇÅ (Œª a, f a b))
  {s : set Œ±} {t : set Œ≤} (hst : bounded (set.image2 f s t)) :
  bounded s ‚à® bounded t :=
begin
  contrapose! hst,
  obtain ‚ü®b, hb‚ü© : t.nonempty := nonempty_of_unbounded hst.2,
  have : ¬¨bounded (set.image2 f s {b}),
  { intro h,
    apply hst.1,
    rw set.image2_singleton_right at h,
    replace h := (hf b).bounded_preimage h,
    refine h.mono (subset_preimage_image _ _) },
  exact mt (bounded.mono (image2_subset subset.rfl (singleton_subset_iff.mpr hb))) this,
end

lemma bounded_of_image2_right {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {K‚ÇÇ : ‚Ñù‚â•0}
  (hf : ‚àÄ a, antilipschitz_with K‚ÇÇ (f a))
  {s : set Œ±} {t : set Œ≤} (hst : bounded (set.image2 f s t)) :
  bounded s ‚à® bounded t :=
or.symm $ bounded_of_image2_left (flip f) hf $ image2_swap f s t ‚ñ∏ hst

end antilipschitz_with

lemma lipschitz_with.to_right_inverse [pseudo_emetric_space Œ±] [pseudo_emetric_space Œ≤] {K : ‚Ñù‚â•0}
  {f : Œ± ‚Üí Œ≤} (hf : lipschitz_with K f) {g : Œ≤ ‚Üí Œ±} (hg : function.right_inverse g f) :
  antilipschitz_with K g :=
Œª x y, by simpa only [hg _] using hf (g x) (g y)

/-- The preimage of a proper space under a Lipschitz homeomorphism is proper. -/
@[protected]
theorem lipschitz_with.proper_space [pseudo_metric_space Œ±] [metric_space Œ≤] [proper_space Œ≤]
  {K : ‚Ñù‚â•0} {f : Œ± ‚âÉ‚Çú Œ≤} (hK : lipschitz_with K f) :
  proper_space Œ± :=
(hK.to_right_inverse f.right_inv).proper_space f.symm.continuous f.symm.surjective
