/-
Copyright (c) 2022 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/

import category_theory.morphism_property
import category_theory.category.Quiv

/-!

# Construction of the localized category

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This file constructs the localized category, obtained by formally inverting
a class of maps `W : morphism_property C` in a category `C`.

We first construct a quiver `loc_quiver W` whose objects are the same as those
of `C` and whose maps are the maps in `C` and placeholders for the formal
inverses of the maps in `W`.

The localized category `W.localization` is obtained by taking the quotient
of the path category of `loc_quiver W` by the congruence generated by four
types of relations.

The obvious functor `Q W : C ‚•§ W.localization` satisfies the universal property
of the localization. Indeed, if `G : C ‚•§ D` sends morphisms in `W` to isomorphisms
in `D` (i.e. we have `hG : W.is_inverted_by G`), then there exists a unique functor
`G' : W.localization ‚•§ D` such that `Q W ‚â´ G' = G`. This `G'` is `lift G hG`.
The expected property of `lift G hG` if expressed by the lemma `fac` and the
uniqueness is expressed by `uniq`.

## References

* [P. Gabriel, M. Zisman, *Calculus of fractions and homotopy theory*][gabriel-zisman-1967]

-/

noncomputable theory

open category_theory.category

namespace category_theory

variables {C : Type*} [category C] (W : morphism_property C) {D : Type*} [category D]

namespace localization

namespace construction

/-- If `W : morphism_property C`, `loc_quiver W` is a quiver with the same objects
as `C`, and whose morphisms are those in `C` and placeholders for formal
inverses of the morphisms in `W`. -/
@[nolint has_nonempty_instance]
structure loc_quiver (W : morphism_property C) := (obj : C)

instance : quiver (loc_quiver W) :=
{ hom := Œª A B, (A.obj ‚ü∂ B.obj) ‚äï { f : B.obj ‚ü∂ A.obj // W f} }

/-- The object in the path category of `loc_quiver W` attached to an object in
the category `C` -/
def Œπ_paths (X : C) : paths (loc_quiver W) := ‚ü®X‚ü©

/-- The morphism in the path category associated to a morphism in the original category. -/
@[simp]
def œà‚ÇÅ {X Y : C} (f : X ‚ü∂ Y) : Œπ_paths W X ‚ü∂ Œπ_paths W Y := paths.of.map (sum.inl f)

/-- The morphism in the path category corresponding to a formal inverse. -/
@[simp]
def œà‚ÇÇ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : Œπ_paths W Y ‚ü∂ Œπ_paths W X :=
paths.of.map (sum.inr ‚ü®w, hw‚ü©)

/-- The relations by which we take the quotient in order to get the localized category. -/
inductive relations : hom_rel (paths (loc_quiver W))
| id (X : C) :
  relations (œà‚ÇÅ W (ùüô X)) (ùüô _)
| comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  relations (œà‚ÇÅ W (f ‚â´ g)) (œà‚ÇÅ W f ‚â´ œà‚ÇÅ W g)
| Winv‚ÇÅ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) :
  relations (œà‚ÇÅ W w ‚â´ œà‚ÇÇ W w hw) (ùüô _)
| Winv‚ÇÇ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) :
  relations (œà‚ÇÇ W w hw ‚â´ œà‚ÇÅ W w) (ùüô _)

end construction

end localization

namespace morphism_property

open localization.construction

/-- The localized category obtained by formally inverting the morphisms
in `W : morphism_property C` -/
@[derive category, nolint has_nonempty_instance]
def localization := category_theory.quotient (localization.construction.relations W)

/-- The obvious functor `C ‚•§ W.localization` -/
def Q : C ‚•§ W.localization :=
{ obj := Œª X, (quotient.functor _).obj (paths.of.obj ‚ü®X‚ü©),
  map := Œª X Y f, (quotient.functor _).map (œà‚ÇÅ W f),
  map_id' := Œª X, quotient.sound _ (relations.id X),
  map_comp' := Œª X Z Y f g, quotient.sound _ (relations.comp f g), }

end morphism_property

namespace localization

namespace construction

variable {W}

/-- The isomorphism in `W.localization` associated to a morphism `w` in W -/
def Wiso {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : iso (W.Q.obj X) (W.Q.obj Y) :=
{ hom := W.Q.map w,
  inv := (quotient.functor _).map (paths.of.map (sum.inr ‚ü®w, hw‚ü©)),
  hom_inv_id' := quotient.sound _ (relations.Winv‚ÇÅ w hw),
  inv_hom_id' := quotient.sound _ (relations.Winv‚ÇÇ w hw), }

/-- The formal inverse in `W.localization` of a morphism `w` in `W`. -/
abbreviation Winv {X Y : C} (w : X ‚ü∂ Y) (hw : W w) := (Wiso w hw).inv

variable (W)

lemma _root_.category_theory.morphism_property.Q_inverts : W.is_inverted_by W.Q :=
Œª X Y w hw, is_iso.of_iso (localization.construction.Wiso w hw)

variables {W} (G : C ‚•§ D) (hG : W.is_inverted_by G)

include G hG

/-- The lifting of a functor to the path category of `loc_quiver W` -/
@[simps]
def lift_to_path_category : paths (loc_quiver W) ‚•§ D :=
Quiv.lift
{ obj := Œª X, G.obj X.obj,
  map := Œª X Y, begin
    rintro (f|‚ü®g, hg‚ü©),
    { exact G.map f, },
    { haveI := hG g hg,
      exact inv (G.map g), },
  end, }

/-- The lifting of a functor `C ‚•§ D` inverting `W` as a functor `W.localization ‚•§ D` -/
@[simps]
def lift : W.localization ‚•§ D :=
quotient.lift (relations W) (lift_to_path_category G hG)
begin
  rintro ‚ü®X‚ü© ‚ü®Y‚ü© f‚ÇÅ f‚ÇÇ r,
  rcases r,
  tidy,
end

@[simp]
lemma fac : W.Q ‚ãô lift G hG = G :=
functor.ext (Œª X, rfl)
begin
  intros X Y f,
  simp only [functor.comp_map, eq_to_hom_refl, comp_id, id_comp],
  dsimp [lift, lift_to_path_category, morphism_property.Q],
  rw compose_path_to_path,
end

omit G hG

lemma uniq (G‚ÇÅ G‚ÇÇ : W.localization ‚•§ D) (h : W.Q ‚ãô G‚ÇÅ = W.Q ‚ãô G‚ÇÇ) :
  G‚ÇÅ = G‚ÇÇ :=
begin
  suffices h' : quotient.functor _ ‚ãô G‚ÇÅ = quotient.functor _ ‚ãô G‚ÇÇ,
  { refine functor.ext _ _,
    { rintro ‚ü®‚ü®X‚ü©‚ü©,
      apply functor.congr_obj h, },
    { rintros ‚ü®‚ü®X‚ü©‚ü© ‚ü®‚ü®Y‚ü©‚ü© ‚ü®f‚ü©,
      apply functor.congr_hom h', }, },
  { refine paths.ext_functor _ _,
    { ext X,
      cases X,
      apply functor.congr_obj h, },
    { rintro ‚ü®X‚ü© ‚ü®Y‚ü© (f|‚ü®w, hw‚ü©),
      { simpa only using functor.congr_hom h f, },
      { have hw : W.Q.map w = (Wiso w hw).hom := rfl,
        have hw' := functor.congr_hom h w,
        simp only [functor.comp_map, hw] at hw',
        refine functor.congr_inv_of_congr_hom _ _ _ _ _ hw',
        all_goals
        { apply functor.congr_obj h, }, }, }, },
end

variable (W)

/-- The canonical bijection between objects in a category and its
localization with respect to a morphism_property `W` -/
@[simps]
def obj_equiv : C ‚âÉ W.localization :=
{ to_fun := W.Q.obj,
  inv_fun := Œª X, X.as.obj,
  left_inv := Œª X, rfl,
  right_inv := by { rintro ‚ü®‚ü®X‚ü©‚ü©, refl, }, }

variable {W}

/-- A `morphism_property` in `W.localization` is satisfied by all
morphisms in the localized category if it contains the image of the
morphisms in the original category, the inverses of the morphisms
in `W` and if it is stable under composition -/
lemma morphism_property_is_top
  (P : morphism_property W.localization)
  (hP‚ÇÅ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), P (W.Q.map f))
  (hP‚ÇÇ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (w : X ‚ü∂ Y) (hw : W w), P (Winv w hw))
  (hP‚ÇÉ : P.stable_under_composition) : P = ‚ä§ :=
begin
  ext X Y f,
  split,
  { intro hf,
    simp only [pi.top_apply], },
  { intro hf, clear hf,
    let G : _ ‚•§ W.localization := quotient.functor _,
    suffices : ‚àÄ (X‚ÇÅ X‚ÇÇ : C) (p : localization.construction.Œπ_paths W X‚ÇÅ ‚ü∂
      localization.construction.Œπ_paths W X‚ÇÇ), P (G.map p),
    { rcases X with ‚ü®‚ü®X‚ü©‚ü©,
      rcases Y with ‚ü®‚ü®Y‚ü©‚ü©,
      simpa only [functor.image_preimage] using this _ _ (G.preimage f), },
    intros X‚ÇÅ X‚ÇÇ p,
    induction p with X‚ÇÇ X‚ÇÉ p g hp,
    { simpa only [functor.map_id] using hP‚ÇÅ (ùüô X‚ÇÅ), },
    { cases X‚ÇÇ,
      cases X‚ÇÉ,
      let p' : Œπ_paths W X‚ÇÅ ‚ü∂ Œπ_paths W X‚ÇÇ := p,
      rw [show p.cons g = p' ‚â´ quiver.hom.to_path g, by refl, G.map_comp],
      refine hP‚ÇÉ _ _ hp _,
      rcases g with (g | ‚ü®g, hg‚ü©),
      { apply hP‚ÇÅ, },
      { apply hP‚ÇÇ, }, }, },
end

/-- A `morphism_property` in `W.localization` is satisfied by all
morphisms in the localized category if it contains the image of the
morphisms in the original category, if is stable under composition
and if the property is stable by passing to inverses. -/
lemma morphism_property_is_top'
  (P : morphism_property W.localization)
  (hP‚ÇÅ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), P (W.Q.map f))
  (hP‚ÇÇ : ‚àÄ ‚¶ÉX Y : W.localization‚¶Ñ (e : X ‚âÖ Y) (he : P e.hom), P e.inv)
  (hP‚ÇÉ : P.stable_under_composition) : P = ‚ä§ :=
morphism_property_is_top P hP‚ÇÅ (Œª X Y w hw, hP‚ÇÇ _ (by exact hP‚ÇÅ w)) hP‚ÇÉ

namespace nat_trans_extension

variables {F‚ÇÅ F‚ÇÇ : W.localization ‚•§ D} (œÑ : W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ)
include œÑ

/-- If `F‚ÇÅ` and `F‚ÇÇ` are functors `W.localization ‚•§ D` and if we have
`œÑ : W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ`, we shall define a natural transformation `F‚ÇÅ ‚ü∂ F‚ÇÇ`.
This is the `app` field of this natural transformation. -/
def app (X : W.localization) : F‚ÇÅ.obj X ‚ü∂ F‚ÇÇ.obj X :=
eq_to_hom (congr_arg F‚ÇÅ.obj ((obj_equiv W).right_inv X).symm) ‚â´
    œÑ.app ((obj_equiv W).inv_fun X) ‚â´ eq_to_hom (congr_arg F‚ÇÇ.obj ((obj_equiv W).right_inv X))

@[simp]
lemma app_eq (X : C) : (app œÑ) (W.Q.obj X) = œÑ.app X :=
by simpa only [app, eq_to_hom_refl, comp_id, id_comp]

end nat_trans_extension

/-- If `F‚ÇÅ` and `F‚ÇÇ` are functors `W.localization ‚•§ D`, a natural transformation `F‚ÇÅ ‚ü∂ F‚ÇÇ`
can be obtained from a natural transformation `W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ`. -/
@[simps]
def nat_trans_extension {F‚ÇÅ F‚ÇÇ : W.localization ‚•§ D} (œÑ : W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ) :
  F‚ÇÅ ‚ü∂ F‚ÇÇ :=
{ app := nat_trans_extension.app œÑ,
  naturality' := Œª X Y f, begin
    have h := morphism_property_is_top'
      (morphism_property.naturality_property (nat_trans_extension.app œÑ)) _
      (morphism_property.naturality_property.is_stable_under_inverse _)
      (morphism_property.naturality_property.is_stable_under_composition _), swap,
    { intros X Y f,
      simpa only [morphism_property.naturality_property, nat_trans_extension.app_eq]
        using œÑ.naturality f, },
    have hf : (‚ä§ : morphism_property _) f := by simp only [pi.top_apply],
    simpa only [‚Üê h] using hf,
  end,  }

@[simp]
lemma nat_trans_extension_hcomp {F G : W.localization ‚•§ D} (œÑ : W.Q ‚ãô F ‚ü∂ W.Q ‚ãô G) :
  (ùüô W.Q) ‚ó´ nat_trans_extension œÑ = œÑ :=
begin
  ext X,
  simp only [nat_trans.hcomp_app, nat_trans.id_app, G.map_id, comp_id,
    nat_trans_extension_app, nat_trans_extension.app_eq],
end

lemma nat_trans_hcomp_injective {F G : W.localization ‚•§ D} {œÑ‚ÇÅ œÑ‚ÇÇ : F ‚ü∂ G}
  (h : ùüô W.Q ‚ó´ œÑ‚ÇÅ = ùüô W.Q ‚ó´ œÑ‚ÇÇ) : œÑ‚ÇÅ = œÑ‚ÇÇ :=
begin
  ext X,
  have eq := (obj_equiv W).right_inv X,
  simp only [obj_equiv] at eq,
  rw [‚Üê eq, ‚Üê nat_trans.id_hcomp_app, ‚Üê nat_trans.id_hcomp_app, h],
end

variables (W D)

namespace whiskering_left_equivalence

/-- The functor `(W.localization ‚•§ D) ‚•§ (W.functors_inverting D)` induced by the
composition with `W.Q : C ‚•§ W.localization`. -/
@[simps]
def functor : (W.localization ‚•§ D) ‚•§ (W.functors_inverting D) :=
full_subcategory.lift _ ((whiskering_left _ _ D).obj W.Q)
  (Œª F, morphism_property.is_inverted_by.of_comp W W.Q W.Q_inverts _)

/-- The function `(W.functors_inverting D) ‚•§ (W.localization ‚•§ D)` induced by
`construction.lift`. -/
@[simps]
def inverse : (W.functors_inverting D) ‚•§ (W.localization ‚•§ D) :=
{ obj := Œª G, lift G.obj G.property,
  map := Œª G‚ÇÅ G‚ÇÇ œÑ, nat_trans_extension (eq_to_hom (by rw fac) ‚â´ œÑ ‚â´ eq_to_hom (by rw fac)),
  map_id' := Œª G, nat_trans_hcomp_injective begin
    rw nat_trans_extension_hcomp,
    ext X,
    simpa only [nat_trans.comp_app, eq_to_hom_app, eq_to_hom_refl, comp_id, id_comp,
      nat_trans.hcomp_id_app, nat_trans.id_app, functor.map_id],
  end,
  map_comp' := Œª G‚ÇÅ G‚ÇÇ G‚ÇÉ œÑ‚ÇÅ œÑ‚ÇÇ, nat_trans_hcomp_injective begin
    ext X,
    simpa only [nat_trans_extension_hcomp, nat_trans.comp_app, eq_to_hom_app, eq_to_hom_refl,
      id_comp, comp_id, nat_trans.hcomp_app, nat_trans.id_app, functor.map_id,
      nat_trans_extension_app, nat_trans_extension.app_eq],
  end, }

/-- The unit isomorphism of the equivalence of categories `whiskering_left_equivalence W D`. -/
@[simps]
def unit_iso : ùü≠ (W.localization ‚•§ D) ‚âÖ functor W D ‚ãô inverse W D := eq_to_iso
begin
  refine functor.ext (Œª G, _) (Œª G‚ÇÅ G‚ÇÇ œÑ, _),
  { apply uniq,
    dsimp [functor],
    rw fac, },
  { apply nat_trans_hcomp_injective,
    ext X,
    simp only [functor.id_map, nat_trans.hcomp_app, comp_id, functor.comp_map,
      inverse_map, nat_trans.comp_app, eq_to_hom_app, eq_to_hom_refl, nat_trans_extension_app,
      nat_trans_extension.app_eq, functor_map_app, id_comp], },
end

/-- The counit isomorphism of the equivalence of categories `whiskering_left_equivalence W D`. -/
@[simps]
def counit_iso : inverse W D ‚ãô functor W D ‚âÖ ùü≠ (W.functors_inverting D) := eq_to_iso
begin
  refine functor.ext _ _,
  { rintro ‚ü®G, hG‚ü©,
    ext1,
    apply fac, },
  { rintros ‚ü®G‚ÇÅ, hG‚ÇÅ‚ü© ‚ü®G‚ÇÇ, hG‚ÇÇ‚ü© f,
    ext X,
    apply nat_trans_extension.app_eq, },
end

end whiskering_left_equivalence

/-- The equivalence of categories `(W.localization ‚•§ D) ‚âå (W.functors_inverting D)`
induced by the composition with `W.Q : C ‚•§ W.localization`. -/
def whiskering_left_equivalence : (W.localization ‚•§ D) ‚âå W.functors_inverting D :=
{ functor := whiskering_left_equivalence.functor W D,
  inverse := whiskering_left_equivalence.inverse W D,
  unit_iso := whiskering_left_equivalence.unit_iso W D,
  counit_iso := whiskering_left_equivalence.counit_iso W D,
  functor_unit_iso_comp' := Œª F, begin
    ext X,
    simpa only [eq_to_hom_app, whiskering_left_equivalence.unit_iso_hom,
      whiskering_left_equivalence.counit_iso_hom, eq_to_hom_map, eq_to_hom_trans,
      eq_to_hom_refl],
  end, }

end construction

end localization

end category_theory
