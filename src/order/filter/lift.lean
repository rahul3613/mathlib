/-
Copyright (c) 2019 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl
-/
import order.filter.bases

/-!
# Lift filters along filter and set functions

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.
-/

open set

open_locale classical filter

namespace filter
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œπ : Sort*}

section lift

/-- A variant on `bind` using a function `g` taking a set instead of a member of `Œ±`.
This is essentially a push-forward along a function mapping each set to a filter. -/
protected def lift (f : filter Œ±) (g : set Œ± ‚Üí filter Œ≤) :=
‚®Ös ‚àà f, g s

variables {f f‚ÇÅ f‚ÇÇ : filter Œ±} {g g‚ÇÅ g‚ÇÇ : set Œ± ‚Üí filter Œ≤}

@[simp] lemma lift_top (g : set Œ± ‚Üí filter Œ≤) : (‚ä§ : filter Œ±).lift g = g univ :=
by simp [filter.lift]

/-- If `(p : Œπ ‚Üí Prop, s : Œπ ‚Üí set Œ±)` is a basis of a filter `f`, `g` is a monotone function
`set Œ± ‚Üí filter Œ≥`, and for each `i`, `(pg : Œ≤ i ‚Üí Prop, sg : Œ≤ i ‚Üí set Œ±)` is a basis
of the filter `g (s i)`, then `(Œª (i : Œπ) (x : Œ≤ i), p i ‚àß pg i x, Œª (i : Œπ) (x : Œ≤ i), sg i x)`
is a basis of the filter `f.lift g`.

This basis is parametrized by `i : Œπ` and `x : Œ≤ i`, so in order to formulate this fact using
`has_basis` one has to use `Œ£ i, Œ≤ i` as the index type, see `filter.has_basis.lift`.
This lemma states the corresponding `mem_iff` statement without using a sigma type. -/
lemma has_basis.mem_lift_iff {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} {f : filter Œ±}
  (hf : f.has_basis p s) {Œ≤ : Œπ ‚Üí Type*} {pg : Œ† i, Œ≤ i ‚Üí Prop} {sg : Œ† i, Œ≤ i ‚Üí set Œ≥}
  {g : set Œ± ‚Üí filter Œ≥} (hg : ‚àÄ i, (g $ s i).has_basis (pg i) (sg i)) (gm : monotone g)
  {s : set Œ≥} :
  s ‚àà f.lift g ‚Üî ‚àÉ (i : Œπ) (hi : p i) (x : Œ≤ i) (hx : pg i x), sg i x ‚äÜ s :=
begin
  refine (mem_binfi_of_directed _ ‚ü®univ, univ_sets _‚ü©).trans _,
  { intros t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ,
    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm $ inter_subset_left _ _,
      gm $ inter_subset_right _ _‚ü© },
  { simp only [‚Üê (hg _).mem_iff],
    exact hf.exists_iff (Œª t‚ÇÅ t‚ÇÇ ht H, gm ht H) }
end

/-- If `(p : Œπ ‚Üí Prop, s : Œπ ‚Üí set Œ±)` is a basis of a filter `f`, `g` is a monotone function
`set Œ± ‚Üí filter Œ≥`, and for each `i`, `(pg : Œ≤ i ‚Üí Prop, sg : Œ≤ i ‚Üí set Œ±)` is a basis
of the filter `g (s i)`, then `(Œª (i : Œπ) (x : Œ≤ i), p i ‚àß pg i x, Œª (i : Œπ) (x : Œ≤ i), sg i x)`
is a basis of the filter `f.lift g`.

This basis is parametrized by `i : Œπ` and `x : Œ≤ i`, so in order to formulate this fact using
`has_basis` one has to use `Œ£ i, Œ≤ i` as the index type. See also `filter.has_basis.mem_lift_iff`
for the corresponding `mem_iff` statement formulated without using a sigma type. -/
lemma has_basis.lift {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} {f : filter Œ±} (hf : f.has_basis p s)
  {Œ≤ : Œπ ‚Üí Type*} {pg : Œ† i, Œ≤ i ‚Üí Prop} {sg : Œ† i, Œ≤ i ‚Üí set Œ≥} {g : set Œ± ‚Üí filter Œ≥}
  (hg : ‚àÄ i, (g $ s i).has_basis (pg i) (sg i)) (gm : monotone g) :
  (f.lift g).has_basis (Œª i : Œ£ i, Œ≤ i, p i.1 ‚àß pg i.1 i.2) (Œª i : Œ£ i, Œ≤ i, sg i.1 i.2) :=
begin
  refine ‚ü®Œª t, (hf.mem_lift_iff hg gm).trans _‚ü©,
  simp [sigma.exists, and_assoc, exists_and_distrib_left]
end

lemma mem_lift_sets (hg : monotone g) {s : set Œ≤} :
  s ‚àà f.lift g ‚Üî ‚àÉt‚ààf, s ‚àà g t :=
(f.basis_sets.mem_lift_iff (Œª s, (g s).basis_sets) hg).trans $
  by simp only [id, exists_mem_subset_iff]

lemma sInter_lift_sets (hg : monotone g) :
  ‚ãÇ‚ÇÄ {s | s ‚àà f.lift g} = ‚ãÇ s ‚àà f, ‚ãÇ‚ÇÄ {t | t ‚àà g s} :=
by simp only [sInter_eq_bInter, mem_set_of_eq, filter.mem_sets, mem_lift_sets hg,
  Inter_exists, @Inter_comm _ (set Œ≤)]

lemma mem_lift {s : set Œ≤} {t : set Œ±} (ht : t ‚àà f) (hs : s ‚àà g t) :
  s ‚àà f.lift g :=
le_principal_iff.mp $ show f.lift g ‚â§ ùìü s,
  from infi_le_of_le t $ infi_le_of_le ht $ le_principal_iff.mpr hs

lemma lift_le {f : filter Œ±} {g : set Œ± ‚Üí filter Œ≤} {h : filter Œ≤} {s : set Œ±}
  (hs : s ‚àà f) (hg : g s ‚â§ h) : f.lift g ‚â§ h :=
infi‚ÇÇ_le_of_le s hs hg

lemma le_lift {f : filter Œ±} {g : set Œ± ‚Üí filter Œ≤} {h : filter Œ≤} :
  h ‚â§ f.lift g ‚Üî ‚àÄ s ‚àà f, h ‚â§ g s :=
le_infi‚ÇÇ_iff

lemma lift_mono (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) : f‚ÇÅ.lift g‚ÇÅ ‚â§ f‚ÇÇ.lift g‚ÇÇ :=
infi_mono $ Œª s, infi_mono' $ Œª hs, ‚ü®hf hs, hg s‚ü©

lemma lift_mono' (hg : ‚àÄs ‚àà f, g‚ÇÅ s ‚â§ g‚ÇÇ s) : f.lift g‚ÇÅ ‚â§ f.lift g‚ÇÇ := infi‚ÇÇ_mono hg

lemma tendsto_lift {m : Œ≥ ‚Üí Œ≤} {l : filter Œ≥} :
  tendsto m l (f.lift g) ‚Üî ‚àÄ s ‚àà f, tendsto m l (g s) :=
by simp only [filter.lift, tendsto_infi]

lemma map_lift_eq {m : Œ≤ ‚Üí Œ≥} (hg : monotone g) : map m (f.lift g) = f.lift (map m ‚àò g) :=
have monotone (map m ‚àò g),
  from map_mono.comp hg,
filter.ext $ Œª s,
  by simp only [mem_lift_sets hg, mem_lift_sets this, exists_prop, mem_map, function.comp_app]

lemma comap_lift_eq {m : Œ≥ ‚Üí Œ≤} : comap m (f.lift g) = f.lift (comap m ‚àò g) :=
by simp only [filter.lift, comap_infi]

theorem comap_lift_eq2 {m : Œ≤ ‚Üí Œ±} {g : set Œ≤ ‚Üí filter Œ≥} (hg : monotone g) :
  (comap m f).lift g = f.lift (g ‚àò preimage m) :=
le_antisymm
  (le_infi‚ÇÇ $ Œª s hs, infi‚ÇÇ_le (m ‚Åª¬π' s) ‚ü®s, hs, subset.rfl‚ü©)
  (le_infi‚ÇÇ $ Œª s ‚ü®s', hs', (h_sub : m ‚Åª¬π' s' ‚äÜ s)‚ü©, infi‚ÇÇ_le_of_le s' hs' $ hg h_sub)

lemma lift_map_le {g : set Œ≤ ‚Üí filter Œ≥} {m : Œ± ‚Üí Œ≤} :
  (map m f).lift g ‚â§ f.lift (g ‚àò image m) :=
le_lift.2 $ Œª s hs, lift_le (image_mem_map hs) le_rfl

lemma map_lift_eq2 {g : set Œ≤ ‚Üí filter Œ≥} {m : Œ± ‚Üí Œ≤} (hg : monotone g) :
  (map m f).lift g = f.lift (g ‚àò image m) :=
lift_map_le.antisymm $ le_lift.2 $ Œª s hs, lift_le hs $ hg $ image_preimage_subset _ _

lemma lift_comm {g : filter Œ≤} {h : set Œ± ‚Üí set Œ≤ ‚Üí filter Œ≥} :
  f.lift (Œªs, g.lift (h s)) = g.lift (Œªt, f.lift (Œªs, h s t)) :=
le_antisymm
  (le_infi $ assume i, le_infi $ assume hi, le_infi $ assume j, le_infi $ assume hj,
    infi_le_of_le j $ infi_le_of_le hj $ infi_le_of_le i $ infi_le _ hi)
  (le_infi $ assume i, le_infi $ assume hi, le_infi $ assume j, le_infi $ assume hj,
    infi_le_of_le j $ infi_le_of_le hj $ infi_le_of_le i $ infi_le _ hi)

lemma lift_assoc {h : set Œ≤ ‚Üí filter Œ≥} (hg : monotone g)  :
  (f.lift g).lift h = f.lift (Œªs, (g s).lift h) :=
le_antisymm
  (le_infi $ assume s, le_infi $ assume hs, le_infi $ assume t, le_infi $ assume ht,
    infi_le_of_le t $ infi_le _ $ (mem_lift_sets hg).mpr ‚ü®_, hs, ht‚ü©)
  (le_infi $ assume t, le_infi $ assume ht,
    let ‚ü®s, hs, h'‚ü© := (mem_lift_sets hg).mp ht in
    infi_le_of_le s $ infi_le_of_le hs $ infi_le_of_le t $ infi_le _ h')

lemma lift_lift_same_le_lift {g : set Œ± ‚Üí set Œ± ‚Üí filter Œ≤} :
  f.lift (Œªs, f.lift (g s)) ‚â§ f.lift (Œªs, g s s) :=
le_lift.2 $ Œª s hs, lift_le hs $ lift_le hs le_rfl

lemma lift_lift_same_eq_lift {g : set Œ± ‚Üí set Œ± ‚Üí filter Œ≤}
  (hg‚ÇÅ : ‚àÄs, monotone (Œªt, g s t)) (hg‚ÇÇ : ‚àÄt, monotone (Œªs, g s t)) :
  f.lift (Œªs, f.lift (g s)) = f.lift (Œªs, g s s) :=
lift_lift_same_le_lift.antisymm $
  le_lift.2 $ Œª s hs, le_lift.2 $ Œª t ht, lift_le (inter_mem hs ht) $
    calc g (s ‚à© t) (s ‚à© t) ‚â§ g s (s ‚à© t) : hg‚ÇÇ (s ‚à© t) (inter_subset_left _ _)
                       ... ‚â§ g s t       : hg‚ÇÅ s (inter_subset_right _ _)

lemma lift_principal {s : set Œ±} (hg : monotone g) :
  (ùìü s).lift g = g s :=
(lift_le (mem_principal_self _) le_rfl).antisymm (le_lift.2 $ Œª t ht, hg ht)

theorem monotone_lift [preorder Œ≥] {f : Œ≥ ‚Üí filter Œ±} {g : Œ≥ ‚Üí set Œ± ‚Üí filter Œ≤}
  (hf : monotone f) (hg : monotone g) : monotone (Œªc, (f c).lift (g c)) :=
assume a b h, lift_mono (hf h) (hg h)

lemma lift_ne_bot_iff (hm : monotone g) : (ne_bot $ f.lift g) ‚Üî (‚àÄs‚ààf, ne_bot (g s)) :=
by simp only [ne_bot_iff, ne.def, ‚Üê empty_mem_iff_bot, mem_lift_sets hm, not_exists]

@[simp] lemma lift_const {f : filter Œ±} {g : filter Œ≤} : f.lift (Œªx, g) = g :=
infi_subtype'.trans infi_const

@[simp] lemma lift_inf {f : filter Œ±} {g h : set Œ± ‚Üí filter Œ≤} :
  f.lift (Œªx, g x ‚äì h x) = f.lift g ‚äì f.lift h :=
by simp only [filter.lift, infi_inf_eq]

@[simp] lemma lift_principal2 {f : filter Œ±} : f.lift ùìü = f :=
le_antisymm
  (assume s hs, mem_lift hs (mem_principal_self s))
  (le_infi $ assume s, le_infi $ assume hs, by simp only [hs, le_principal_iff])

lemma lift_infi_le {f : Œπ ‚Üí filter Œ±} {g : set Œ± ‚Üí filter Œ≤} :
  (infi f).lift g ‚â§ ‚®Ö i, (f i).lift g :=
le_infi $ Œª i, lift_mono (infi_le _ _) le_rfl

lemma lift_infi [nonempty Œπ] {f : Œπ ‚Üí filter Œ±} {g : set Œ± ‚Üí filter Œ≤}
  (hg : ‚àÄ s t, g (s ‚à© t) = g s ‚äì g t) : (infi f).lift g = (‚®Öi, (f i).lift g) :=
begin
  refine lift_infi_le.antisymm (Œª s, _),
  have H : ‚àÄ t ‚àà infi f, (‚®Ö i, (f i).lift g) ‚â§ g t,
  { intros t ht,
    refine infi_sets_induct ht _ (Œª i s t hs ht, _),
    { inhabit Œπ,
      exact infi‚ÇÇ_le_of_le default univ (infi_le _ univ_mem) },
    { rw hg,
      exact le_inf (infi‚ÇÇ_le_of_le i s $ infi_le _ hs) ht } },
  simp only [mem_lift_sets (monotone.of_map_inf hg), exists_imp_distrib],
  exact Œª t ht hs, H t ht hs
end

lemma lift_infi_of_directed [nonempty Œπ] {f : Œπ ‚Üí filter Œ±} {g : set Œ± ‚Üí filter Œ≤}
  (hf : directed (‚â•) f) (hg : monotone g) : (infi f).lift g = (‚®Öi, (f i).lift g) :=
lift_infi_le.antisymm $ Œª s,
  begin
    simp only [mem_lift_sets hg, exists_imp_distrib, mem_infi_of_directed hf],
    exact assume t i ht hs, mem_infi_of_mem i $ mem_lift ht hs
  end

lemma lift_infi_of_map_univ {f : Œπ ‚Üí filter Œ±} {g : set Œ± ‚Üí filter Œ≤}
  (hg : ‚àÄ s t, g (s ‚à© t) = g s ‚äì g t) (hg' : g univ = ‚ä§) :
  (infi f).lift g = (‚®Öi, (f i).lift g) :=
begin
  casesI is_empty_or_nonempty Œπ,
  { simp [infi_of_empty, hg'] },
  { exact lift_infi hg }
end

end lift

section lift'
/-- Specialize `lift` to functions `set Œ± ‚Üí set Œ≤`. This can be viewed as a generalization of `map`.
This is essentially a push-forward along a function mapping each set to a set. -/
protected def lift' (f : filter Œ±) (h : set Œ± ‚Üí set Œ≤) :=
f.lift (ùìü ‚àò h)

variables {f f‚ÇÅ f‚ÇÇ : filter Œ±} {h h‚ÇÅ h‚ÇÇ : set Œ± ‚Üí set Œ≤}

@[simp] lemma lift'_top (h : set Œ± ‚Üí set Œ≤) : (‚ä§ : filter Œ±).lift' h = ùìü (h univ) :=
lift_top _

lemma mem_lift' {t : set Œ±} (ht : t ‚àà f) : h t ‚àà (f.lift' h) :=
le_principal_iff.mp $ show f.lift' h ‚â§ ùìü (h t),
  from infi_le_of_le t $ infi_le_of_le ht $ le_rfl

lemma tendsto_lift' {m : Œ≥ ‚Üí Œ≤} {l : filter Œ≥} :
  tendsto m l (f.lift' h) ‚Üî ‚àÄ s ‚àà f, ‚àÄ·∂† a in l, m a ‚àà h s :=
by simp only [filter.lift', tendsto_lift, tendsto_principal]

lemma has_basis.lift' {Œπ} {p : Œπ ‚Üí Prop} {s} (hf : f.has_basis p s) (hh : monotone h) :
  (f.lift' h).has_basis p (h ‚àò s) :=
begin
  refine ‚ü®Œª t, (hf.mem_lift_iff _ (monotone_principal.comp hh)).trans _‚ü©,
  show ‚àÄ i, (ùìü (h (s i))).has_basis (Œª j : unit, true) (Œª (j : unit), h (s i)),
    from Œª i, has_basis_principal _,
  simp only [exists_const]
end

lemma mem_lift'_sets (hh : monotone h) {s : set Œ≤} : s ‚àà f.lift' h ‚Üî ‚àÉ t ‚àà f, h t ‚äÜ s :=
mem_lift_sets $ monotone_principal.comp hh

lemma eventually_lift'_iff (hh : monotone h) {p : Œ≤ ‚Üí Prop} :
  (‚àÄ·∂† y in f.lift' h, p y) ‚Üî (‚àÉ t ‚àà f, ‚àÄ y ‚àà h t, p y) :=
mem_lift'_sets hh

lemma sInter_lift'_sets (hh : monotone h) :
  ‚ãÇ‚ÇÄ {s | s ‚àà f.lift' h} = ‚ãÇ s ‚àà f, h s :=
(sInter_lift_sets (monotone_principal.comp hh)).trans $ Inter‚ÇÇ_congr $ Œª s hs, cInf_Ici

lemma lift'_le {f : filter Œ±} {g : set Œ± ‚Üí set Œ≤} {h : filter Œ≤} {s : set Œ±}
  (hs : s ‚àà f) (hg : ùìü (g s) ‚â§ h) : f.lift' g ‚â§ h :=
lift_le hs hg

lemma lift'_mono (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hh : h‚ÇÅ ‚â§ h‚ÇÇ) : f‚ÇÅ.lift' h‚ÇÅ ‚â§ f‚ÇÇ.lift' h‚ÇÇ :=
lift_mono hf $ assume s, principal_mono.mpr $ hh s

lemma lift'_mono' (hh : ‚àÄs‚ààf, h‚ÇÅ s ‚äÜ h‚ÇÇ s) : f.lift' h‚ÇÅ ‚â§ f.lift' h‚ÇÇ :=
infi‚ÇÇ_mono $ Œª s hs, principal_mono.mpr $ hh s hs

lemma lift'_cong (hh : ‚àÄs‚ààf, h‚ÇÅ s = h‚ÇÇ s) : f.lift' h‚ÇÅ = f.lift' h‚ÇÇ :=
le_antisymm (lift'_mono' $ assume s hs, le_of_eq $ hh s hs)
  (lift'_mono' $ assume s hs, le_of_eq $ (hh s hs).symm)

lemma map_lift'_eq {m : Œ≤ ‚Üí Œ≥} (hh : monotone h) : map m (f.lift' h) = f.lift' (image m ‚àò h) :=
calc map m (f.lift' h) = f.lift (map m ‚àò ùìü ‚àò h) :
    map_lift_eq $ monotone_principal.comp hh
  ... = f.lift' (image m ‚àò h) : by simp only [(‚àò), filter.lift', map_principal, eq_self_iff_true]

lemma lift'_map_le {g : set Œ≤ ‚Üí set Œ≥} {m : Œ± ‚Üí Œ≤} : (map m f).lift' g ‚â§ f.lift' (g ‚àò image m) :=
lift_map_le

lemma map_lift'_eq2 {g : set Œ≤ ‚Üí set Œ≥} {m : Œ± ‚Üí Œ≤} (hg : monotone g) :
  (map m f).lift' g = f.lift' (g ‚àò image m) :=
map_lift_eq2 $ monotone_principal.comp hg

theorem comap_lift'_eq {m : Œ≥ ‚Üí Œ≤} : comap m (f.lift' h) = f.lift' (preimage m ‚àò h) :=
by simp only [filter.lift', comap_lift_eq, (‚àò), comap_principal]

theorem comap_lift'_eq2 {m : Œ≤ ‚Üí Œ±} {g : set Œ≤ ‚Üí set Œ≥} (hg : monotone g) :
  (comap m f).lift' g = f.lift' (g ‚àò preimage m) :=
comap_lift_eq2 $ monotone_principal.comp hg

lemma lift'_principal {s : set Œ±} (hh : monotone h) :
  (ùìü s).lift' h = ùìü (h s) :=
lift_principal $ monotone_principal.comp hh

lemma lift'_pure {a : Œ±} (hh : monotone h) :
  (pure a : filter Œ±).lift' h = ùìü (h {a}) :=
by rw [‚Üê principal_singleton, lift'_principal hh]

lemma lift'_bot (hh : monotone h) : (‚ä• : filter Œ±).lift' h = ùìü (h ‚àÖ) :=
by rw [‚Üê principal_empty, lift'_principal hh]

lemma le_lift' {f : filter Œ±} {h : set Œ± ‚Üí set Œ≤} {g : filter Œ≤} :
  g ‚â§ f.lift' h ‚Üî ‚àÄ s ‚àà f, h s ‚àà g :=
le_lift.trans $ forall‚ÇÇ_congr $ Œª s hs, le_principal_iff

lemma principal_le_lift' {t : set Œ≤} : ùìü t ‚â§ f.lift' h ‚Üî ‚àÄ s ‚àà f, t ‚äÜ h s := le_lift'

theorem monotone_lift' [preorder Œ≥] {f : Œ≥ ‚Üí filter Œ±} {g : Œ≥ ‚Üí set Œ± ‚Üí set Œ≤}
  (hf : monotone f) (hg : monotone g) : monotone (Œªc, (f c).lift' (g c)) :=
assume a b h, lift'_mono (hf h) (hg h)

lemma lift_lift'_assoc {g : set Œ± ‚Üí set Œ≤} {h : set Œ≤ ‚Üí filter Œ≥}
  (hg : monotone g) (hh : monotone h) :
  (f.lift' g).lift h = f.lift (Œªs, h (g s)) :=
calc (f.lift' g).lift h = f.lift (Œªs, (ùìü (g s)).lift h) :
    lift_assoc (monotone_principal.comp hg)
  ... = f.lift (Œªs, h (g s)) : by simp only [lift_principal, hh, eq_self_iff_true]

lemma lift'_lift'_assoc {g : set Œ± ‚Üí set Œ≤} {h : set Œ≤ ‚Üí set Œ≥}
  (hg : monotone g) (hh : monotone h) :
  (f.lift' g).lift' h = f.lift' (Œªs, h (g s)) :=
lift_lift'_assoc hg (monotone_principal.comp hh)

lemma lift'_lift_assoc {g : set Œ± ‚Üí filter Œ≤} {h : set Œ≤ ‚Üí set Œ≥}
  (hg : monotone g) : (f.lift g).lift' h = f.lift (Œªs, (g s).lift' h) :=
lift_assoc hg

lemma lift_lift'_same_le_lift' {g : set Œ± ‚Üí set Œ± ‚Üí set Œ≤} :
  f.lift (Œªs, f.lift' (g s)) ‚â§ f.lift' (Œªs, g s s) :=
lift_lift_same_le_lift

lemma lift_lift'_same_eq_lift' {g : set Œ± ‚Üí set Œ± ‚Üí set Œ≤}
  (hg‚ÇÅ : ‚àÄs, monotone (Œªt, g s t)) (hg‚ÇÇ : ‚àÄt, monotone (Œªs, g s t)) :
  f.lift (Œªs, f.lift' (g s)) = f.lift' (Œªs, g s s) :=
lift_lift_same_eq_lift
  (assume s, monotone_principal.comp (hg‚ÇÅ s))
  (assume t, monotone_principal.comp (hg‚ÇÇ t))

lemma lift'_inf_principal_eq {h : set Œ± ‚Üí set Œ≤} {s : set Œ≤} :
  f.lift' h ‚äì ùìü s = f.lift' (Œªt, h t ‚à© s) :=
by simp only [filter.lift', filter.lift, (‚àò), ‚Üê inf_principal, infi_subtype', ‚Üê infi_inf]

lemma lift'_ne_bot_iff (hh : monotone h) : (ne_bot (f.lift' h)) ‚Üî (‚àÄs‚ààf, (h s).nonempty) :=
calc (ne_bot (f.lift' h)) ‚Üî (‚àÄs‚ààf, ne_bot (ùìü (h s))) :
    lift_ne_bot_iff (monotone_principal.comp hh)
  ... ‚Üî (‚àÄs‚ààf, (h s).nonempty) : by simp only [principal_ne_bot_iff]

@[simp] lemma lift'_id {f : filter Œ±} : f.lift' id = f :=
lift_principal2

lemma lift'_infi [nonempty Œπ] {f : Œπ ‚Üí filter Œ±} {g : set Œ± ‚Üí set Œ≤}
  (hg : ‚àÄ s t, g (s ‚à© t) = g s ‚à© g t) : (infi f).lift' g = (‚®Ö i, (f i).lift' g) :=
lift_infi $ Œª s t, by rw [inf_principal, (‚àò), ‚Üê hg]

lemma lift'_infi_of_map_univ {f : Œπ ‚Üí filter Œ±} {g : set Œ± ‚Üí set Œ≤}
  (hg : ‚àÄ{s t}, g (s ‚à© t) = g s ‚à© g t) (hg' : g univ = univ) :
  (infi f).lift' g = (‚®Ö i, (f i).lift' g) :=
lift_infi_of_map_univ (Œª s t, by rw [inf_principal, (‚àò), ‚Üê hg])
  (by rw [function.comp_app, hg', principal_univ])

lemma lift'_inf (f g : filter Œ±) {s : set Œ± ‚Üí set Œ≤} (hs : ‚àÄ t‚ÇÅ t‚ÇÇ, s (t‚ÇÅ ‚à© t‚ÇÇ) = s t‚ÇÅ ‚à© s t‚ÇÇ) :
  (f ‚äì g).lift' s = f.lift' s ‚äì g.lift' s :=
have (‚®Ö b : bool, cond b f g).lift' s = ‚®Ö b : bool, (cond b f g).lift' s :=
  lift'_infi @hs,
by simpa only [infi_bool_eq]

lemma lift'_inf_le (f g : filter Œ±) (s : set Œ± ‚Üí set Œ≤) :
  (f ‚äì g).lift' s ‚â§ f.lift' s ‚äì g.lift' s :=
le_inf (lift'_mono inf_le_left le_rfl) (lift'_mono inf_le_right le_rfl)

theorem comap_eq_lift' {f : filter Œ≤} {m : Œ± ‚Üí Œ≤} :
  comap m f = f.lift' (preimage m) :=
filter.ext $ Œª s, (mem_lift'_sets monotone_preimage).symm

end lift'

section prod
variables {f : filter Œ±}

lemma prod_def {f : filter Œ±} {g : filter Œ≤} : f √ó·∂† g = (f.lift $ Œª s, g.lift' $ Œª t, s √óÀ¢ t) :=
have ‚àÄ(s:set Œ±) (t : set Œ≤),
    ùìü (s √óÀ¢ t) = (ùìü s).comap prod.fst ‚äì (ùìü t).comap prod.snd,
  by simp only [principal_eq_iff_eq, comap_principal, inf_principal]; intros; refl,
begin
  simp only [filter.lift', function.comp, this, lift_inf, lift_const, lift_inf],
  rw [‚Üê comap_lift_eq, ‚Üê comap_lift_eq],
  simp only [filter.prod, lift_principal2]
end

lemma prod_same_eq : f √ó·∂† f = f.lift' (Œª t : set Œ±, t √óÀ¢ t) :=
prod_def.trans $ lift_lift'_same_eq_lift'
  (Œª s, monotone_const.set_prod monotone_id)
  (Œª t, monotone_id.set_prod monotone_const)

lemma mem_prod_same_iff {s : set (Œ±√óŒ±)} :
  s ‚àà f √ó·∂† f ‚Üî (‚àÉt‚ààf, t √óÀ¢ t ‚äÜ s) :=
by { rw [prod_same_eq, mem_lift'_sets], exact monotone_id.set_prod monotone_id }

lemma tendsto_prod_self_iff {f : Œ± √ó Œ± ‚Üí Œ≤} {x : filter Œ±} {y : filter Œ≤} :
  filter.tendsto f (x √ó·∂† x) y ‚Üî
  ‚àÄ W ‚àà y, ‚àÉ U ‚àà x, ‚àÄ (x x' : Œ±), x ‚àà U ‚Üí x' ‚àà U ‚Üí f (x, x') ‚àà W :=
by simp only [tendsto_def, mem_prod_same_iff, prod_sub_preimage_iff, exists_prop, iff_self]

variables {Œ±‚ÇÅ : Type*} {Œ±‚ÇÇ : Type*} {Œ≤‚ÇÅ : Type*} {Œ≤‚ÇÇ : Type*}

lemma prod_lift_lift
  {f‚ÇÅ : filter Œ±‚ÇÅ} {f‚ÇÇ : filter Œ±‚ÇÇ} {g‚ÇÅ : set Œ±‚ÇÅ ‚Üí filter Œ≤‚ÇÅ} {g‚ÇÇ : set Œ±‚ÇÇ ‚Üí filter Œ≤‚ÇÇ}
  (hg‚ÇÅ : monotone g‚ÇÅ) (hg‚ÇÇ : monotone g‚ÇÇ) :
  (f‚ÇÅ.lift g‚ÇÅ) √ó·∂† (f‚ÇÇ.lift g‚ÇÇ) = f‚ÇÅ.lift (Œªs, f‚ÇÇ.lift (Œªt, g‚ÇÅ s √ó·∂† g‚ÇÇ t)) :=
begin
  simp only [prod_def, lift_assoc hg‚ÇÅ],
  apply congr_arg, funext x,
  rw [lift_comm],
  apply congr_arg, funext y,
  apply lift'_lift_assoc hg‚ÇÇ
end

lemma prod_lift'_lift'
  {f‚ÇÅ : filter Œ±‚ÇÅ} {f‚ÇÇ : filter Œ±‚ÇÇ} {g‚ÇÅ : set Œ±‚ÇÅ ‚Üí set Œ≤‚ÇÅ} {g‚ÇÇ : set Œ±‚ÇÇ ‚Üí set Œ≤‚ÇÇ}
  (hg‚ÇÅ : monotone g‚ÇÅ) (hg‚ÇÇ : monotone g‚ÇÇ) :
  f‚ÇÅ.lift' g‚ÇÅ √ó·∂† f‚ÇÇ.lift' g‚ÇÇ = f‚ÇÅ.lift (Œª s, f‚ÇÇ.lift' (Œª t, g‚ÇÅ s √óÀ¢ g‚ÇÇ t)) :=
calc f‚ÇÅ.lift' g‚ÇÅ √ó·∂† f‚ÇÇ.lift' g‚ÇÇ = f‚ÇÅ.lift (Œª s, f‚ÇÇ.lift (Œª t, ùìü (g‚ÇÅ s) √ó·∂† ùìü (g‚ÇÇ t))) :
  prod_lift_lift (monotone_principal.comp hg‚ÇÅ) (monotone_principal.comp hg‚ÇÇ)
... = f‚ÇÅ.lift (Œª s, f‚ÇÇ.lift (Œª t, ùìü (g‚ÇÅ s √óÀ¢ g‚ÇÇ t))) :
  by simp only [prod_principal_principal]

end prod

end filter
