/-
Copyright (c) 2022 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johanes H√∂lzl, Patrick Massot, Yury Kudryashov, Kevin Wilson, Heather Macbeth
-/
import order.filter.basic

/-!
# Product and coproduct filters

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file we define `filter.prod f g` (notation: `f √ó·∂† g`) and `filter.coprod f g`. The product
of two filters is the largest filter `l` such that `filter.tendsto prod.fst l f` and
`filter.tendsto prod.snd l g`.

## Implementation details

The product filter cannot be defined using the monad structure on filters. For example:

```lean
F := do {x ‚Üê seq, y ‚Üê top, return (x, y)}
G := do {y ‚Üê top, x ‚Üê seq, return (x, y)}
```
hence:
```lean
s ‚àà F  ‚Üî  ‚àÉ n, [n..‚àû] √ó univ ‚äÜ s
s ‚àà G  ‚Üî  ‚àÄ i:‚Ñï, ‚àÉ n, [n..‚àû] √ó {i} ‚äÜ s
```
Now `‚ãÉ i, [i..‚àû] √ó {i}` is in `G` but not in `F`.
As product filter we want to have `F` as result.

## Notations

* `f √ó·∂† g` : `filter.prod f g`, localized in `filter`.

-/

open set
open_locale filter

namespace filter

variables {Œ± Œ≤ Œ≥ Œ¥ : Type*} {Œπ : Sort*}

section prod
variables {s : set Œ±} {t : set Œ≤} {f : filter Œ±} {g : filter Œ≤}

/-- Product of filters. This is the filter generated by cartesian products
of elements of the component filters. -/
protected def prod (f : filter Œ±) (g : filter Œ≤) : filter (Œ± √ó Œ≤) :=
f.comap prod.fst ‚äì g.comap prod.snd

localized "infix (name := filter.prod) ` √ó·∂† `:60 := filter.prod" in filter

lemma prod_mem_prod {s : set Œ±} {t : set Œ≤} {f : filter Œ±} {g : filter Œ≤}
  (hs : s ‚àà f) (ht : t ‚àà g) : s √óÀ¢ t ‚àà f √ó·∂† g :=
inter_mem_inf (preimage_mem_comap hs) (preimage_mem_comap ht)

lemma mem_prod_iff {s : set (Œ±√óŒ≤)} {f : filter Œ±} {g : filter Œ≤} :
  s ‚àà f √ó·∂† g ‚Üî (‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ √óÀ¢ t‚ÇÇ ‚äÜ s) :=
begin
  simp only [filter.prod],
  split,
  { rintro ‚ü®t‚ÇÅ, ‚ü®s‚ÇÅ, hs‚ÇÅ, hts‚ÇÅ‚ü©, t‚ÇÇ, ‚ü®s‚ÇÇ, hs‚ÇÇ, hts‚ÇÇ‚ü©, rfl‚ü©,
    exact  ‚ü®s‚ÇÅ, hs‚ÇÅ, s‚ÇÇ, hs‚ÇÇ, Œª p ‚ü®h, h'‚ü©, ‚ü®hts‚ÇÅ h, hts‚ÇÇ h'‚ü©‚ü© },
  { rintro ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, h‚ü©,
    exact mem_inf_of_inter (preimage_mem_comap ht‚ÇÅ) (preimage_mem_comap ht‚ÇÇ) h }
end

@[simp] lemma prod_mem_prod_iff {s : set Œ±} {t : set Œ≤} {f : filter Œ±} {g : filter Œ≤}
  [f.ne_bot] [g.ne_bot] :
  s √óÀ¢ t ‚àà f √ó·∂† g ‚Üî s ‚àà f ‚àß t ‚àà g :=
‚ü®Œª h, let ‚ü®s', hs', t', ht', H‚ü© := mem_prod_iff.1 h in (prod_subset_prod_iff.1 H).elim
  (Œª ‚ü®hs's, ht't‚ü©, ‚ü®mem_of_superset hs' hs's, mem_of_superset ht' ht't‚ü©)
  (Œª h, h.elim
    (Œª hs'e, absurd hs'e (nonempty_of_mem hs').ne_empty)
    (Œª ht'e, absurd ht'e (nonempty_of_mem ht').ne_empty)),
  Œª h, prod_mem_prod h.1 h.2‚ü©

lemma mem_prod_principal {f : filter Œ±} {s : set (Œ± √ó Œ≤)} {t : set Œ≤}:
  s ‚àà f √ó·∂† ùìü t ‚Üî {a | ‚àÄ b ‚àà t, (a, b) ‚àà s} ‚àà f :=
begin
  rw [‚Üê @exists_mem_subset_iff _ f, mem_prod_iff],
  refine exists‚ÇÇ_congr (Œª u u_in, ‚ü®_, Œª h, ‚ü®t, mem_principal_self t, _‚ü©‚ü©),
  { rintros ‚ü®v, v_in, hv‚ü© a a_in b b_in,
    exact hv (mk_mem_prod a_in $ v_in b_in) },
  { rintro ‚ü®x, y‚ü© ‚ü®hx, hy‚ü©,
    exact h hx y hy }
end

lemma mem_prod_top {f : filter Œ±} {s : set (Œ± √ó Œ≤)} :
  s ‚àà f √ó·∂† (‚ä§ : filter Œ≤) ‚Üî {a | ‚àÄ b, (a, b) ‚àà s} ‚àà f :=
begin
  rw [‚Üê principal_univ, mem_prod_principal],
  simp only [mem_univ, forall_true_left]
end

lemma eventually_prod_principal_iff {p : Œ± √ó Œ≤ ‚Üí Prop} {s : set Œ≤} :
  (‚àÄ·∂† (x : Œ± √ó Œ≤) in (f √ó·∂† (ùìü s)), p x) ‚Üî ‚àÄ·∂† (x : Œ±) in f, ‚àÄ (y : Œ≤), y ‚àà s ‚Üí p (x, y) :=
by { rw [eventually_iff, eventually_iff, mem_prod_principal], simp only [mem_set_of_eq], }

lemma comap_prod (f : Œ± ‚Üí Œ≤ √ó Œ≥) (b : filter Œ≤) (c : filter Œ≥) :
  comap f (b √ó·∂† c) = (comap (prod.fst ‚àò f) b) ‚äì (comap (prod.snd ‚àò f) c) :=
by erw [comap_inf, filter.comap_comap, filter.comap_comap]

lemma prod_top {f : filter Œ±} : f √ó·∂† (‚ä§ : filter Œ≤) = f.comap prod.fst :=
by rw [filter.prod, comap_top, inf_top_eq]

lemma sup_prod (f‚ÇÅ f‚ÇÇ : filter Œ±) (g : filter Œ≤) : (f‚ÇÅ ‚äî f‚ÇÇ) √ó·∂† g = (f‚ÇÅ √ó·∂† g) ‚äî (f‚ÇÇ √ó·∂† g) :=
by rw [filter.prod, comap_sup, inf_sup_right, ‚Üê filter.prod, ‚Üê filter.prod]

lemma prod_sup (f : filter Œ±) (g‚ÇÅ g‚ÇÇ : filter Œ≤) : f √ó·∂† (g‚ÇÅ ‚äî g‚ÇÇ) = (f √ó·∂† g‚ÇÅ) ‚äî (f √ó·∂† g‚ÇÇ) :=
by rw [filter.prod, comap_sup, inf_sup_left, ‚Üê filter.prod, ‚Üê filter.prod]

lemma eventually_prod_iff {p : Œ± √ó Œ≤ ‚Üí Prop} {f : filter Œ±} {g : filter Œ≤} :
  (‚àÄ·∂† x in f √ó·∂† g, p x) ‚Üî ‚àÉ (pa : Œ± ‚Üí Prop) (ha : ‚àÄ·∂† x in f, pa x)
    (pb : Œ≤ ‚Üí Prop) (hb : ‚àÄ·∂† y in g, pb y), ‚àÄ {x}, pa x ‚Üí ‚àÄ {y}, pb y ‚Üí p (x, y) :=
by simpa only [set.prod_subset_iff] using @mem_prod_iff Œ± Œ≤ p f g

lemma tendsto_fst {f : filter Œ±} {g : filter Œ≤} : tendsto prod.fst (f √ó·∂† g) f :=
tendsto_inf_left tendsto_comap

lemma tendsto_snd {f : filter Œ±} {g : filter Œ≤} : tendsto prod.snd (f √ó·∂† g) g :=
tendsto_inf_right tendsto_comap

lemma tendsto.prod_mk {f : filter Œ±} {g : filter Œ≤} {h : filter Œ≥} {m‚ÇÅ : Œ± ‚Üí Œ≤} {m‚ÇÇ : Œ± ‚Üí Œ≥}
  (h‚ÇÅ : tendsto m‚ÇÅ f g) (h‚ÇÇ : tendsto m‚ÇÇ f h) : tendsto (Œª x, (m‚ÇÅ x, m‚ÇÇ x)) f (g √ó·∂† h) :=
tendsto_inf.2 ‚ü®tendsto_comap_iff.2 h‚ÇÅ, tendsto_comap_iff.2 h‚ÇÇ‚ü©

lemma tendsto_prod_swap {Œ±1 Œ±2 : Type*} {a1 : filter Œ±1} {a2 : filter Œ±2} :
  tendsto (prod.swap : Œ±1 √ó Œ±2 ‚Üí Œ±2 √ó Œ±1) (a1 √ó·∂† a2) (a2 √ó·∂† a1) :=
tendsto_snd.prod_mk tendsto_fst

lemma eventually.prod_inl {la : filter Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in la, p x) (lb : filter Œ≤) :
  ‚àÄ·∂† x in la √ó·∂† lb, p (x : Œ± √ó Œ≤).1 :=
tendsto_fst.eventually h

lemma eventually.prod_inr {lb : filter Œ≤} {p : Œ≤ ‚Üí Prop} (h : ‚àÄ·∂† x in lb, p x) (la : filter Œ±) :
  ‚àÄ·∂† x in la √ó·∂† lb, p (x : Œ± √ó Œ≤).2 :=
tendsto_snd.eventually h

lemma eventually.prod_mk {la : filter Œ±} {pa : Œ± ‚Üí Prop} (ha : ‚àÄ·∂† x in la, pa x)
  {lb : filter Œ≤} {pb : Œ≤ ‚Üí Prop} (hb : ‚àÄ·∂† y in lb, pb y) :
  ‚àÄ·∂† p in la √ó·∂† lb, pa (p : Œ± √ó Œ≤).1 ‚àß pb p.2 :=
(ha.prod_inl lb).and (hb.prod_inr la)

lemma eventually_eq.prod_map {Œ¥} {la : filter Œ±} {fa ga : Œ± ‚Üí Œ≥} (ha : fa =·∂†[la] ga)
  {lb : filter Œ≤} {fb gb : Œ≤ ‚Üí Œ¥} (hb : fb =·∂†[lb] gb) :
  prod.map fa fb =·∂†[la √ó·∂† lb] prod.map ga gb :=
(eventually.prod_mk ha hb).mono $ Œª x h, prod.ext h.1 h.2

lemma eventually_le.prod_map {Œ¥} [has_le Œ≥] [has_le Œ¥] {la : filter Œ±} {fa ga : Œ± ‚Üí Œ≥}
  (ha : fa ‚â§·∂†[la] ga) {lb : filter Œ≤} {fb gb : Œ≤ ‚Üí Œ¥} (hb : fb ‚â§·∂†[lb] gb) :
  prod.map fa fb ‚â§·∂†[la √ó·∂† lb] prod.map ga gb :=
eventually.prod_mk ha hb

lemma eventually.curry {la : filter Œ±} {lb : filter Œ≤} {p : Œ± √ó Œ≤ ‚Üí Prop}
  (h : ‚àÄ·∂† x in la √ó·∂† lb, p x) :
  ‚àÄ·∂† x in la, ‚àÄ·∂† y in lb, p (x, y) :=
begin
  rcases eventually_prod_iff.1 h with ‚ü®pa, ha, pb, hb, h‚ü©,
  exact ha.mono (Œª a ha, hb.mono $ Œª b hb, h ha hb)
end

/-- A fact that is eventually true about all pairs `l √ó·∂† l` is eventually true about
all diagonal pairs `(i, i)` -/
lemma eventually.diag_of_prod {f : filter Œ±} {p : Œ± √ó Œ± ‚Üí Prop}
  (h : ‚àÄ·∂† i in f √ó·∂† f, p i) : (‚àÄ·∂† i in f, p (i, i)) :=
begin
  obtain ‚ü®t, ht, s, hs, hst‚ü© := eventually_prod_iff.1 h,
  apply (ht.and hs).mono (Œª x hx, hst hx.1 hx.2),
end

lemma eventually.diag_of_prod_left {f : filter Œ±} {g : filter Œ≥}
  {p : (Œ± √ó Œ±) √ó Œ≥ ‚Üí Prop} :
  (‚àÄ·∂† x in (f √ó·∂† f √ó·∂† g), p x) ‚Üí
  (‚àÄ·∂† (x : Œ± √ó Œ≥) in (f √ó·∂† g), p ((x.1, x.1), x.2)) :=
begin
  intros h,
  obtain ‚ü®t, ht, s, hs, hst‚ü© := eventually_prod_iff.1 h,
  refine (ht.diag_of_prod.prod_mk hs).mono (Œª x hx, by simp only [hst hx.1 hx.2, prod.mk.eta]),
end

lemma eventually.diag_of_prod_right {f : filter Œ±} {g : filter Œ≥}
  {p : Œ± √ó Œ≥ √ó Œ≥ ‚Üí Prop} :
  (‚àÄ·∂† x in (f √ó·∂† (g √ó·∂† g)), p x) ‚Üí
  (‚àÄ·∂† (x : Œ± √ó Œ≥) in (f √ó·∂† g), p (x.1, x.2, x.2)) :=
begin
  intros h,
  obtain ‚ü®t, ht, s, hs, hst‚ü© := eventually_prod_iff.1 h,
  refine (ht.prod_mk hs.diag_of_prod).mono (Œª x hx, by simp only [hst hx.1 hx.2, prod.mk.eta]),
end

lemma tendsto_diag : tendsto (Œª i, (i, i)) f (f √ó·∂† f) :=
tendsto_iff_eventually.mpr (Œª _ hpr, hpr.diag_of_prod)

lemma prod_infi_left [nonempty Œπ] {f : Œπ ‚Üí filter Œ±} {g : filter Œ≤}:
  (‚®Ö i, f i) √ó·∂† g = (‚®Ö i, (f i) √ó·∂† g) :=
by { rw [filter.prod, comap_infi, infi_inf], simp only [filter.prod, eq_self_iff_true] }

lemma prod_infi_right [nonempty Œπ] {f : filter Œ±} {g : Œπ ‚Üí filter Œ≤} :
  f √ó·∂† (‚®Ö i, g i) = (‚®Ö i, f √ó·∂† (g i)) :=
by { rw [filter.prod, comap_infi, inf_infi], simp only [filter.prod, eq_self_iff_true] }

@[mono] lemma prod_mono {f‚ÇÅ f‚ÇÇ : filter Œ±} {g‚ÇÅ g‚ÇÇ : filter Œ≤} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) :
  f‚ÇÅ √ó·∂† g‚ÇÅ ‚â§ f‚ÇÇ √ó·∂† g‚ÇÇ :=
inf_le_inf (comap_mono hf) (comap_mono hg)

lemma prod_mono_left (g : filter Œ≤) {f‚ÇÅ f‚ÇÇ : filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) :
  f‚ÇÅ √ó·∂† g ‚â§ f‚ÇÇ √ó·∂† g :=
filter.prod_mono hf rfl.le

lemma prod_mono_right (f : filter Œ±) {g‚ÇÅ g‚ÇÇ : filter Œ≤} (hf : g‚ÇÅ ‚â§ g‚ÇÇ) :
  f √ó·∂† g‚ÇÅ ‚â§ f √ó·∂† g‚ÇÇ :=
filter.prod_mono rfl.le hf

lemma {u v w x} prod_comap_comap_eq {Œ±‚ÇÅ : Type u} {Œ±‚ÇÇ : Type v} {Œ≤‚ÇÅ : Type w} {Œ≤‚ÇÇ : Type x}
  {f‚ÇÅ : filter Œ±‚ÇÅ} {f‚ÇÇ : filter Œ±‚ÇÇ} {m‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ} {m‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ} :
  (comap m‚ÇÅ f‚ÇÅ) √ó·∂† (comap m‚ÇÇ f‚ÇÇ) = comap (Œª p : Œ≤‚ÇÅ√óŒ≤‚ÇÇ, (m‚ÇÅ p.1, m‚ÇÇ p.2)) (f‚ÇÅ √ó·∂† f‚ÇÇ) :=
by simp only [filter.prod, comap_comap, eq_self_iff_true, comap_inf]

lemma prod_comm' : f √ó·∂† g = comap (prod.swap) (g √ó·∂† f) :=
by simp only [filter.prod, comap_comap, (‚àò), inf_comm, prod.fst_swap,
  eq_self_iff_true, prod.snd_swap, comap_inf]

lemma prod_comm : f √ó·∂† g = map (Œª p : Œ≤√óŒ±, (p.2, p.1)) (g √ó·∂† f) :=
by { rw [prod_comm', ‚Üê map_swap_eq_comap_swap], refl }

@[simp] lemma map_fst_prod (f : filter Œ±) (g : filter Œ≤) [ne_bot g] : map prod.fst (f √ó·∂† g) = f :=
begin
  refine le_antisymm tendsto_fst (Œª s hs, _),
  rw [mem_map, mem_prod_iff] at hs,
  rcases hs with ‚ü®t‚ÇÅ, h‚ÇÅ, t‚ÇÇ, h‚ÇÇ, hs‚ü©,
  rw [‚Üê image_subset_iff, fst_image_prod] at hs,
  exacts [mem_of_superset h‚ÇÅ hs, nonempty_of_mem h‚ÇÇ]
end

@[simp] lemma map_snd_prod (f : filter Œ±) (g : filter Œ≤) [ne_bot f] : map prod.snd (f √ó·∂† g) = g :=
by rw [prod_comm, map_map, (‚àò), map_fst_prod]

@[simp] lemma prod_le_prod {f‚ÇÅ f‚ÇÇ : filter Œ±} {g‚ÇÅ g‚ÇÇ : filter Œ≤} [ne_bot f‚ÇÅ] [ne_bot g‚ÇÅ] :
  f‚ÇÅ √ó·∂† g‚ÇÅ ‚â§ f‚ÇÇ √ó·∂† g‚ÇÇ ‚Üî f‚ÇÅ ‚â§ f‚ÇÇ ‚àß g‚ÇÅ ‚â§ g‚ÇÇ :=
‚ü®Œª h, ‚ü®map_fst_prod f‚ÇÅ g‚ÇÅ ‚ñ∏ tendsto_fst.mono_left h, map_snd_prod f‚ÇÅ g‚ÇÅ ‚ñ∏ tendsto_snd.mono_left h‚ü©,
  Œª h, prod_mono h.1 h.2‚ü©

@[simp] lemma prod_inj {f‚ÇÅ f‚ÇÇ : filter Œ±} {g‚ÇÅ g‚ÇÇ : filter Œ≤} [ne_bot f‚ÇÅ] [ne_bot g‚ÇÅ] :
  f‚ÇÅ √ó·∂† g‚ÇÅ = f‚ÇÇ √ó·∂† g‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ ‚àß g‚ÇÅ = g‚ÇÇ :=
begin
  refine ‚ü®Œª h, _, Œª h, h.1 ‚ñ∏ h.2 ‚ñ∏ rfl‚ü©,
  have hle : f‚ÇÅ ‚â§ f‚ÇÇ ‚àß g‚ÇÅ ‚â§ g‚ÇÇ := prod_le_prod.1 h.le,
  haveI := ne_bot_of_le hle.1, haveI := ne_bot_of_le hle.2,
  exact ‚ü®hle.1.antisymm $ (prod_le_prod.1 h.ge).1, hle.2.antisymm $ (prod_le_prod.1 h.ge).2‚ü©
end

lemma eventually_swap_iff {p : (Œ± √ó Œ≤) ‚Üí Prop} : (‚àÄ·∂† (x : Œ± √ó Œ≤) in (f √ó·∂† g), p x) ‚Üî
  ‚àÄ·∂† (y : Œ≤ √ó Œ±) in (g √ó·∂† f), p y.swap :=
by { rw [prod_comm, eventually_map], simpa, }

lemma prod_assoc (f : filter Œ±) (g : filter Œ≤) (h : filter Œ≥) :
  map (equiv.prod_assoc Œ± Œ≤ Œ≥) ((f √ó·∂† g) √ó·∂† h) = f √ó·∂† (g √ó·∂† h) :=
by simp_rw [‚Üê comap_equiv_symm, filter.prod, comap_inf, comap_comap, inf_assoc, function.comp,
  equiv.prod_assoc_symm_apply]

theorem prod_assoc_symm (f : filter Œ±) (g : filter Œ≤) (h : filter Œ≥) :
map (equiv.prod_assoc Œ± Œ≤ Œ≥).symm (f √ó·∂† (g √ó·∂† h)) = (f √ó·∂† g) √ó·∂† h :=
by simp_rw [map_equiv_symm, filter.prod, comap_inf, comap_comap, inf_assoc, function.comp,
  equiv.prod_assoc_apply]

lemma tendsto_prod_assoc {f : filter Œ±} {g : filter Œ≤} {h : filter Œ≥} :
  tendsto (equiv.prod_assoc Œ± Œ≤ Œ≥) (f √ó·∂† g √ó·∂† h) (f √ó·∂† (g √ó·∂† h)) :=
(prod_assoc f g h).le

lemma tendsto_prod_assoc_symm {f : filter Œ±} {g : filter Œ≤} {h : filter Œ≥} :
  tendsto (equiv.prod_assoc Œ± Œ≤ Œ≥).symm (f √ó·∂† (g √ó·∂† h)) (f √ó·∂† g √ó·∂† h) :=
(prod_assoc_symm f g h).le

/-- A useful lemma when dealing with uniformities. -/
lemma map_swap4_prod {f : filter Œ±} {g : filter Œ≤} {h : filter Œ≥} {k : filter Œ¥} :
  map (Œª p : (Œ± √ó Œ≤) √ó (Œ≥ √ó Œ¥), ((p.1.1, p.2.1), (p.1.2, p.2.2))) ((f √ó·∂† g) √ó·∂† (h √ó·∂† k)) =
  (f √ó·∂† h) √ó·∂† (g √ó·∂† k) :=
by simp_rw [map_swap4_eq_comap, filter.prod, comap_inf, comap_comap, inf_assoc, inf_left_comm]

lemma tendsto_swap4_prod {f : filter Œ±} {g : filter Œ≤} {h : filter Œ≥} {k : filter Œ¥} :
  tendsto (Œª p : (Œ± √ó Œ≤) √ó (Œ≥ √ó Œ¥), ((p.1.1, p.2.1), (p.1.2, p.2.2)))
    ((f √ó·∂† g) √ó·∂† (h √ó·∂† k)) ((f √ó·∂† h) √ó·∂† (g √ó·∂† k)) :=
map_swap4_prod.le

lemma {u v w x} prod_map_map_eq {Œ±‚ÇÅ : Type u} {Œ±‚ÇÇ : Type v} {Œ≤‚ÇÅ : Type w} {Œ≤‚ÇÇ : Type x}
  {f‚ÇÅ : filter Œ±‚ÇÅ} {f‚ÇÇ : filter Œ±‚ÇÇ} {m‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ} {m‚ÇÇ : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ} :
  (map m‚ÇÅ f‚ÇÅ) √ó·∂† (map m‚ÇÇ f‚ÇÇ) = map (Œª p : Œ±‚ÇÅ√óŒ±‚ÇÇ, (m‚ÇÅ p.1, m‚ÇÇ p.2)) (f‚ÇÅ √ó·∂† f‚ÇÇ) :=
le_antisymm
  (Œª s hs,
    let ‚ü®s‚ÇÅ, hs‚ÇÅ, s‚ÇÇ, hs‚ÇÇ, h‚ü© := mem_prod_iff.mp hs in
    filter.sets_of_superset _ (prod_mem_prod (image_mem_map hs‚ÇÅ) (image_mem_map hs‚ÇÇ)) $
      calc (m‚ÇÅ '' s‚ÇÅ) √óÀ¢ (m‚ÇÇ '' s‚ÇÇ) = (Œª p : Œ±‚ÇÅ√óŒ±‚ÇÇ, (m‚ÇÅ p.1, m‚ÇÇ p.2)) '' s‚ÇÅ √óÀ¢ s‚ÇÇ :
          set.prod_image_image_eq
        ... ‚äÜ _ : by rwa [image_subset_iff])
  ((tendsto.comp le_rfl tendsto_fst).prod_mk (tendsto.comp le_rfl tendsto_snd))

lemma prod_map_map_eq' {Œ±‚ÇÅ : Type*} {Œ±‚ÇÇ : Type*} {Œ≤‚ÇÅ : Type*} {Œ≤‚ÇÇ : Type*}
  (f : Œ±‚ÇÅ ‚Üí Œ±‚ÇÇ) (g : Œ≤‚ÇÅ ‚Üí Œ≤‚ÇÇ) (F : filter Œ±‚ÇÅ) (G : filter Œ≤‚ÇÅ) :
  (map f F) √ó·∂† (map g G) = map (prod.map f g) (F √ó·∂† G) :=
prod_map_map_eq

lemma le_prod_map_fst_snd {f : filter (Œ± √ó Œ≤)} : f ‚â§ map prod.fst f √ó·∂† map prod.snd f :=
le_inf le_comap_map le_comap_map

lemma tendsto.prod_map {Œ¥ : Type*} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {a : filter Œ±} {b : filter Œ≤}
  {c : filter Œ≥} {d : filter Œ¥} (hf : tendsto f a c) (hg : tendsto g b d) :
  tendsto (prod.map f g) (a √ó·∂† b) (c √ó·∂† d) :=
begin
  erw [tendsto, ‚Üê prod_map_map_eq],
  exact filter.prod_mono hf hg,
end

protected lemma map_prod (m : Œ± √ó Œ≤ ‚Üí Œ≥) (f : filter Œ±) (g : filter Œ≤) :
  map m (f √ó·∂† g) = (f.map (Œª a b, m (a, b))).seq g :=
begin
  simp [filter.ext_iff, mem_prod_iff, mem_map_seq_iff],
  intro s,
  split,
  exact Œª ‚ü®t, ht, s, hs, h‚ü©, ‚ü®s, hs, t, ht, Œª x hx y hy, @h ‚ü®x, y‚ü© ‚ü®hx, hy‚ü©‚ü©,
  exact Œª ‚ü®s, hs, t, ht, h‚ü©, ‚ü®t, ht, s, hs, Œª ‚ü®x, y‚ü© ‚ü®hx, hy‚ü©, h x hx y hy‚ü©
end

lemma prod_eq {f : filter Œ±} {g : filter Œ≤} : f √ó·∂† g = (f.map prod.mk).seq g  :=
have h : _ := f.map_prod id g, by rwa [map_id] at h

lemma prod_inf_prod {f‚ÇÅ f‚ÇÇ : filter Œ±} {g‚ÇÅ g‚ÇÇ : filter Œ≤} :
  (f‚ÇÅ √ó·∂† g‚ÇÅ) ‚äì (f‚ÇÇ √ó·∂† g‚ÇÇ) = (f‚ÇÅ ‚äì f‚ÇÇ) √ó·∂† (g‚ÇÅ ‚äì g‚ÇÇ) :=
by simp only [filter.prod, comap_inf, inf_comm, inf_assoc, inf_left_comm]

@[simp] lemma prod_bot {f : filter Œ±} : f √ó·∂† (‚ä• : filter Œ≤) = ‚ä• := by simp [filter.prod]
@[simp] lemma bot_prod {g : filter Œ≤} : (‚ä• : filter Œ±) √ó·∂† g = ‚ä• := by simp [filter.prod]

@[simp] lemma prod_principal_principal {s : set Œ±} {t : set Œ≤} :
  (ùìü s) √ó·∂† (ùìü t) = ùìü (s √óÀ¢ t) :=
by simp only [filter.prod, comap_principal, principal_eq_iff_eq, comap_principal, inf_principal];
  refl

@[simp] lemma pure_prod {a : Œ±} {f : filter Œ≤} : pure a √ó·∂† f = map (prod.mk a) f :=
by rw [prod_eq, map_pure, pure_seq_eq_map]

lemma map_pure_prod (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Œ±) (B : filter Œ≤) :
  filter.map (function.uncurry f) (pure a √ó·∂† B) = filter.map (f a) B :=
by { rw filter.pure_prod, refl }

@[simp] lemma prod_pure {f : filter Œ±} {b : Œ≤} : f √ó·∂† pure b = map (Œª a, (a, b)) f :=
by rw [prod_eq, seq_pure, map_map]

lemma prod_pure_pure {a : Œ±} {b : Œ≤} : (pure a) √ó·∂† (pure b) = pure (a, b) :=
by simp

lemma prod_eq_bot {f : filter Œ±} {g : filter Œ≤} : f √ó·∂† g = ‚ä• ‚Üî (f = ‚ä• ‚à® g = ‚ä•) :=
begin
  split,
  { intro h,
    rcases mem_prod_iff.1 (empty_mem_iff_bot.2 h) with ‚ü®s, hs, t, ht, hst‚ü©,
    rw [subset_empty_iff, set.prod_eq_empty_iff] at hst,
    cases hst with s_eq t_eq,
    { left, exact empty_mem_iff_bot.1 (s_eq ‚ñ∏ hs) },
    { right, exact empty_mem_iff_bot.1 (t_eq ‚ñ∏ ht) } },
  { rintro (rfl | rfl),
    exact bot_prod,
    exact prod_bot }
end

lemma prod_ne_bot {f : filter Œ±} {g : filter Œ≤} : ne_bot (f √ó·∂† g) ‚Üî (ne_bot f ‚àß ne_bot g) :=
by simp only [ne_bot_iff, ne, prod_eq_bot, not_or_distrib]

lemma ne_bot.prod {f : filter Œ±} {g : filter Œ≤} (hf : ne_bot f) (hg : ne_bot g) :
  ne_bot (f √ó·∂† g) :=
prod_ne_bot.2 ‚ü®hf, hg‚ü©

instance prod_ne_bot' {f : filter Œ±} {g : filter Œ≤} [hf : ne_bot f] [hg : ne_bot g] :
  ne_bot (f √ó·∂† g) :=
hf.prod hg

lemma tendsto_prod_iff {f : Œ± √ó Œ≤ ‚Üí Œ≥} {x : filter Œ±} {y : filter Œ≤} {z : filter Œ≥} :
  filter.tendsto f (x √ó·∂† y) z ‚Üî
  ‚àÄ W ‚àà z, ‚àÉ U ‚àà x,  ‚àÉ V ‚àà y, ‚àÄ x y, x ‚àà U ‚Üí y ‚àà V ‚Üí f (x, y) ‚àà W :=
by simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop, iff_self]

lemma tendsto_prod_iff' {f : filter Œ±} {g : filter Œ≤} {g' : filter Œ≥}
  {s : Œ± ‚Üí Œ≤ √ó Œ≥} :
  tendsto s f (g √ó·∂† g') ‚Üî tendsto (Œª n, (s n).1) f g ‚àß tendsto (Œª n, (s n).2) f g' :=
by { unfold filter.prod, simp only [tendsto_inf, tendsto_comap_iff, iff_self] }

end prod

/-! ### Coproducts of filters -/

section coprod
variables {f : filter Œ±} {g : filter Œ≤}

/-- Coproduct of filters. -/
protected def coprod (f : filter Œ±) (g : filter Œ≤) : filter (Œ± √ó Œ≤) :=
f.comap prod.fst ‚äî g.comap prod.snd

lemma mem_coprod_iff {s : set (Œ±√óŒ≤)} {f : filter Œ±} {g : filter Œ≤} :
  s ‚àà f.coprod g ‚Üî ((‚àÉ t‚ÇÅ ‚àà f, prod.fst ‚Åª¬π' t‚ÇÅ ‚äÜ s) ‚àß (‚àÉ t‚ÇÇ ‚àà g, prod.snd ‚Åª¬π' t‚ÇÇ ‚äÜ s)) :=
by simp [filter.coprod]

@[simp] lemma bot_coprod (l : filter Œ≤) : (‚ä• : filter Œ±).coprod l = comap prod.snd l :=
by simp [filter.coprod]

@[simp] lemma coprod_bot (l : filter Œ±) : l.coprod (‚ä• : filter Œ≤) = comap prod.fst l :=
by simp [filter.coprod]

lemma bot_coprod_bot : (‚ä• : filter Œ±).coprod (‚ä• : filter Œ≤) = ‚ä• := by simp

lemma compl_mem_coprod {s : set (Œ± √ó Œ≤)} {la : filter Œ±} {lb : filter Œ≤} :
  s·∂ú ‚àà la.coprod lb ‚Üî (prod.fst '' s)·∂ú ‚àà la ‚àß (prod.snd '' s)·∂ú ‚àà lb :=
by simp only [filter.coprod, mem_sup, compl_mem_comap]

@[mono] lemma coprod_mono {f‚ÇÅ f‚ÇÇ : filter Œ±} {g‚ÇÅ g‚ÇÇ : filter Œ≤} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) :
  f‚ÇÅ.coprod g‚ÇÅ ‚â§ f‚ÇÇ.coprod g‚ÇÇ :=
sup_le_sup (comap_mono hf) (comap_mono hg)

lemma coprod_ne_bot_iff : (f.coprod g).ne_bot ‚Üî f.ne_bot ‚àß nonempty Œ≤ ‚à® nonempty Œ± ‚àß g.ne_bot :=
by simp [filter.coprod]

@[instance] lemma coprod_ne_bot_left [ne_bot f] [nonempty Œ≤] : (f.coprod g).ne_bot :=
coprod_ne_bot_iff.2 (or.inl ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©)

@[instance] lemma coprod_ne_bot_right [ne_bot g] [nonempty Œ±] : (f.coprod g).ne_bot :=
coprod_ne_bot_iff.2 (or.inr ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©)

lemma principal_coprod_principal (s : set Œ±) (t : set Œ≤) :
  (ùìü s).coprod (ùìü t) = ùìü (s·∂ú √óÀ¢ t·∂ú)·∂ú :=
by rw [filter.coprod, comap_principal, comap_principal, sup_principal, set.prod_eq, compl_inter,
  preimage_compl, preimage_compl, compl_compl, compl_compl]

-- this inequality can be strict; see `map_const_principal_coprod_map_id_principal` and
-- `map_prod_map_const_id_principal_coprod_principal` below.
lemma {u v w x} map_prod_map_coprod_le {Œ±‚ÇÅ : Type u} {Œ±‚ÇÇ : Type v} {Œ≤‚ÇÅ : Type w} {Œ≤‚ÇÇ : Type x}
  {f‚ÇÅ : filter Œ±‚ÇÅ} {f‚ÇÇ : filter Œ±‚ÇÇ} {m‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ} {m‚ÇÇ : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ} :
  map (prod.map m‚ÇÅ m‚ÇÇ) (f‚ÇÅ.coprod f‚ÇÇ) ‚â§ (map m‚ÇÅ f‚ÇÅ).coprod (map m‚ÇÇ f‚ÇÇ) :=
begin
  intros s,
  simp only [mem_map, mem_coprod_iff],
  rintro ‚ü®‚ü®u‚ÇÅ, hu‚ÇÅ, h‚ÇÅ‚ü©, u‚ÇÇ, hu‚ÇÇ, h‚ÇÇ‚ü©,
  refine ‚ü®‚ü®m‚ÇÅ ‚Åª¬π' u‚ÇÅ, hu‚ÇÅ, Œª _ hx, h‚ÇÅ _‚ü©, ‚ü®m‚ÇÇ ‚Åª¬π' u‚ÇÇ, hu‚ÇÇ, Œª _ hx, h‚ÇÇ _‚ü©‚ü©; convert hx
end

/-- Characterization of the coproduct of the `filter.map`s of two principal filters `ùìü {a}` and
`ùìü {i}`, the first under the constant function `Œª a, b` and the second under the identity function.
Together with the next lemma, `map_prod_map_const_id_principal_coprod_principal`, this provides an
example showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict. -/
lemma map_const_principal_coprod_map_id_principal {Œ± Œ≤ Œπ : Type*} (a : Œ±) (b : Œ≤) (i : Œπ) :
  (map (Œª _ : Œ±, b) (ùìü {a})).coprod (map id (ùìü {i}))
  = ùìü (({b} : set Œ≤) √óÀ¢ univ ‚à™ univ √óÀ¢ ({i} : set Œπ)) :=
by simp only [map_principal, filter.coprod, comap_principal, sup_principal, image_singleton,
  image_id, prod_univ, univ_prod]

/-- Characterization of the `filter.map` of the coproduct of two principal filters `ùìü {a}` and
`ùìü {i}`, under the `prod.map` of two functions, respectively the constant function `Œª a, b` and the
identity function.  Together with the previous lemma,
`map_const_principal_coprod_map_id_principal`, this provides an example showing that the inequality
in the lemma `map_prod_map_coprod_le` can be strict. -/
lemma map_prod_map_const_id_principal_coprod_principal {Œ± Œ≤ Œπ : Type*} (a : Œ±) (b : Œ≤) (i : Œπ) :
  map (prod.map (Œª _ : Œ±, b) id) ((ùìü {a}).coprod (ùìü {i}))
  = ùìü (({b} : set Œ≤) √óÀ¢ (univ : set Œπ)) :=
begin
  rw [principal_coprod_principal, map_principal],
  congr,
  ext ‚ü®b', i'‚ü©,
  split,
  { rintro ‚ü®‚ü®a'', i''‚ü©, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©,
    simp },
  { rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    use (a, i'),
    simpa using h‚ÇÅ.symm }
end

lemma tendsto.prod_map_coprod {Œ¥ : Type*} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {a : filter Œ±} {b : filter Œ≤}
  {c : filter Œ≥} {d : filter Œ¥} (hf : tendsto f a c) (hg : tendsto g b d) :
  tendsto (prod.map f g) (a.coprod b) (c.coprod d) :=
map_prod_map_coprod_le.trans (coprod_mono hf hg)

end coprod

end filter
